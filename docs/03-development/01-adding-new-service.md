# Adding a New Service to the Microservices Architecture

## Table of Contents

- [Overview](#overview)
- [Step-by-Step Guide](#step-by-step-guide)
  - [1. Generate the Service Structure](#1-generate-the-service-structure)
  - [2. Configure Database in Docker](#2-configure-database-in-docker)
  - [3. Set Up Prisma](#3-set-up-prisma)
  - [4. Configure GraphQL Module](#4-configure-graphql-module)
  - [5. Create Feature Module](#5-create-feature-module)
  - [6. Register with API Gateway](#6-register-with-api-gateway)
  - [7. Configure Code Generation](#7-configure-code-generation)
  - [8. Create GraphQL Operations](#8-create-graphql-operations)
  - [9. Update Development Scripts](#9-update-development-scripts)
  - [10. Federation - Extending Types (Optional)](#10-federation---extending-types-optional)
- [Running the New Service](#running-the-new-service)
- [Checklist](#checklist)
- [Troubleshooting](#troubleshooting)
  - [Port Conflicts](#port-conflicts)
  - [TypeScript Errors](#typescript-errors)
  - [Database Connection](#database-connection)
  - [Gateway Registration](#gateway-registration)

This guide explains how to add a new microservice to the NestJS GraphQL Federation architecture.

## Overview

Each service in this architecture:
- Has its own PostgreSQL database
- Exposes a GraphQL subgraph
- Is registered with the Apollo Gateway
- Uses Prisma as ORM
- Has TypeScript types generated by GraphQL Code Generator

## Step-by-Step Guide

### 1. Generate the Service Structure

Use Nx to scaffold a new NestJS application:

```bash
nx g @nx/nest:app <service-name>
# Example: nx g @nx/nest:app orders-service
```

### 2. Configure Database in Docker

Add a new PostgreSQL container in `docker-compose.yml`:

```yaml
postgres-<service>:
  image: postgres:16-alpine
  container_name: nestjs-<service>-db
  environment:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_DB: <service>_db
  ports:
    - '543X:5432'  # Use next available port (5434, 5435, etc.)
  volumes:
    - postgres-<service>-data:/var/lib/postgresql/data
```

Don't forget to add the volume:

```yaml
volumes:
  postgres-<service>-data:
```

### 3. Set Up Prisma

#### Create Prisma Schema

Create `apps/<service-name>/prisma/schema.prisma`:

```prisma
generator client {
  provider = "prisma-client-js"
  output   = "../../../node_modules/@prisma/client-<service>"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model YourModel {
  id        String   @id @default(uuid())
  // Add your fields here
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

#### Create Environment File

Create `apps/<service-name>/.env`:

```env
DATABASE_URL="postgresql://postgres:postgres@localhost:543X/<service>_db?schema=public"
PORT=300X
```

#### Add Prisma Scripts

Add to `package.json`:

```json
"prisma:generate:<service>": "dotenv -e apps/<service-name>/.env -- prisma generate --schema=apps/<service-name>/prisma/schema.prisma",
"prisma:migrate:<service>": "dotenv -e apps/<service-name>/.env -- prisma migrate dev --schema=apps/<service-name>/prisma/schema.prisma",
"prisma:seed:<service>": "cd apps/<service-name> && dotenv -e .env -- ts-node --project tsconfig.seed.json prisma/seed.ts",
"prisma:studio:<service>": "dotenv -e apps/<service-name>/.env -- prisma studio --schema=apps/<service-name>/prisma/schema.prisma --port 555X",
"start:<service>": "nx serve <service-name>",
```

### 4. Configure GraphQL Module

Update `apps/<service-name>/src/app/app.module.ts`:

```typescript
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { ApolloFederationDriver, ApolloFederationDriverConfig } from '@nestjs/apollo';

@Module({
  imports: [
    GraphQLModule.forRoot<ApolloFederationDriverConfig>({
      driver: ApolloFederationDriver,
      autoSchemaFile: {
        federation: 2,
      },
      playground: true,
    }),
    // Add your feature modules here
  ],
})
export class AppModule {}
```

### 5. Create Feature Module

Create your feature module structure:

```
apps/<service-name>/src/app/<feature>/
├── <feature>.module.ts
├── <feature>.resolver.ts
├── <feature>.service.ts
├── dto/
│   ├── create-<entity>.input.ts
│   └── update-<entity>.input.ts
└── entities/
    └── <entity>.entity.ts
```

### 6. Register with API Gateway

Update `apps/api-gateway/src/app/app.module.ts`:

```typescript
GraphQLModule.forRoot<ApolloGatewayDriverConfig>({
  driver: ApolloGatewayDriver,
  server: {
    playground: true,
  },
  gateway: {
    supergraphSdl: new IntrospectAndCompose({
      subgraphs: [
        { name: 'users', url: 'http://localhost:3001/graphql' },
        { name: 'products', url: 'http://localhost:3002/graphql' },
        { name: '<service>', url: 'http://localhost:300X/graphql' }, // Add your service
      ],
    }),
  },
}),
```

### 7. Configure Code Generation

Add to `codegen.yml`:

```yaml
# <Service> service schema extraction
apps/<service-name>/src/generated/<service>-schema.graphql:
  schema:
    - http://localhost:300X/graphql
  plugins:
    - schema-ast
  config:
    includeDirectives: true
    federation: true
    
# <Service> service types
apps/<service-name>/src/generated/graphql.ts:
  schema:
    - http://localhost:300X/graphql
  plugins:
    - add:
        content: |
          /* eslint-disable */
          import type { I_Service, IQuery__EntitiesArgs } from '@libs/codegen';
    - typescript
    - typescript-resolvers
  config:
    enumsAsTypes: true
    nonOptionalTypename: true
    scalars:
      DateTime: string
    federation: true
    avoidOptionals: true
    mappers:
      YourModel: "@prisma/client-<service>#YourModel as YourModelModel"
    contextType: "@libs/codegen#IGraphQLContext"
    typesPrefix: 'I'
    typesSuffix: ''
    skipTypename: false
    useTypeImports: true
```

### 8. Create GraphQL Operations

Create `libs/codegen/src/operations/<service>.graphql`:

```graphql
query GetAll<Entities> {
  <entities> {
    id
    # Add fields
    createdAt
    updatedAt
  }
}

query Get<Entity>ById($id: String!) {
  <entity>(id: $id) {
    id
    # Add fields
    createdAt
    updatedAt
  }
}

mutation Create<Entity>($create<Entity>Input: Create<Entity>Input!) {
  create<Entity>(create<Entity>Input: $create<Entity>Input) {
    id
    # Add fields
  }
}

mutation Update<Entity>($update<Entity>Input: Update<Entity>Input!) {
  update<Entity>(update<Entity>Input: $update<Entity>Input) {
    id
    # Add fields
  }
}

mutation Remove<Entity>($id: String!) {
  remove<Entity>(id: $id) {
    id
  }
}
```

### 9. Update Development Scripts

Update the `dev` script in `package.json`:

```json
"dev": "concurrently \"pnpm start:users\" \"pnpm start:products\" \"pnpm start:<service>\" \"sleep 10 && pnpm start:gateway\""
```

### 10. Federation - Extending Types (Optional)

If your service needs to extend types from other services:

```typescript
// In your entity
@Directive('@key(fields: "id")')
@ObjectType()
export class YourEntity {
  @Field(() => ID)
  id: string;

  @Field()
  userId: string;

  // Extend User type
  @Field(() => User)
  user?: User;
}

// In your resolver
@ResolveField(() => User)
async user(@Parent() entity: YourEntity) {
  return { __typename: 'User', id: entity.userId };
}
```

## Running the New Service

1. Start Docker containers: `pnpm docker:up`
2. Generate Prisma client: `pnpm prisma:generate:<service>`
3. Run migrations: `pnpm prisma:migrate:<service>`
4. Seed database (optional): `pnpm prisma:seed:<service>`
5. Start all services: `pnpm dev`
6. Generate GraphQL types: `pnpm codegen`

## Checklist

- [ ] Service generated with Nx
- [ ] PostgreSQL container configured
- [ ] Prisma schema created
- [ ] Environment variables set
- [ ] Package.json scripts added
- [ ] GraphQL module configured
- [ ] Feature module implemented
- [ ] Service registered in gateway
- [ ] Codegen configuration added
- [ ] GraphQL operations created
- [ ] Dev script updated
- [ ] Service starts successfully
- [ ] GraphQL types generated

## Troubleshooting

### Port Conflicts
- Ensure each service uses a unique port (3001, 3002, 3003, etc.)
- Database ports should also be unique (5432, 5433, 5434, etc.)

### TypeScript Errors
- Run `pnpm codegen` after starting all services
- Check that federation types are imported correctly

### Database Connection
- Verify DATABASE_URL in .env file
- Ensure Docker container is running
- Check port mapping in docker-compose.yml

### Gateway Registration
- Service must be running before gateway starts
- Check the service URL in gateway configuration
- Verify the subgraph name matches across configurations