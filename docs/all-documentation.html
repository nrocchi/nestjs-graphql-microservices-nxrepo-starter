<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Documentation - NestJS GraphQL Microservices Documentation</title>
    <link href="https://cdn.jsdelivr.net/npm/github-markdown-css@5.5.0/github-markdown.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/github-dark.min.css" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #c9d1d9;
            background: #0d1117;
        }
        .container {
            display: flex;
            min-height: 100vh;
        }
        .sidebar {
            width: 300px;
            background: #161b22;
            border-right: 1px solid #30363d;
            overflow-y: auto;
            position: fixed;
            height: 100vh;
            padding: 20px;
            padding-bottom: 80px; /* Space for author */
        }
        .sidebar h1 {
            font-size: 18px;
            margin-bottom: 30px;
            color: #f0f6fc;
        }
        .sidebar h2 {
            font-size: 16px;
            font-weight: 600;
            margin: 20px 0 10px 0;
            color: #f0f6fc;
        }
        .sidebar ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .sidebar li {
            margin: 5px 0;
        }
        .sidebar a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 14px;
            display: block;
            padding: 5px 10px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }
        .sidebar a:hover {
            background-color: #1f2428;
        }
        .sidebar a.active {
            background-color: #1f6feb;
            color: white;
        }
        /* Search box */
        .search-box {
            margin-bottom: 20px;
            position: relative;
        }
        .search-box input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #30363d;
            border-radius: 6px;
            background: #0d1117;
            color: #c9d1d9;
            font-size: 14px;
        }
        .search-box input:focus {
            outline: none;
            border-color: #58a6ff;
        }
        .search-box input::placeholder {
            color: #8b949e;
        }
        .content {
            margin-left: 320px;
            flex: 1;
            padding: 20px 40px;
            background: #0d1117;
            min-height: 100vh;
        }
        .markdown-body {
            max-width: 980px;
            margin: 0 auto;
            background: #0d1117;
            color: #c9d1d9;
        }
        /* Override github-markdown styles for dark mode */
        .markdown-body h1 {
            color: #f0f6fc;
            border-bottom-color: #30363d;
            font-size: 2.5em !important;
            margin-top: 24px;
            margin-bottom: 16px;
        }
        .markdown-body h2 {
            color: #f0f6fc;
            border-bottom-color: #30363d;
            font-size: 2em !important;
            margin-top: 24px;
            margin-bottom: 16px;
        }
        .markdown-body h3 {
            color: #f0f6fc;
            font-size: 1.5em !important;
            margin-top: 24px;
            margin-bottom: 16px;
        }
        .markdown-body h4 {
            color: #f0f6fc;
            font-size: 1.25em !important;
            margin-top: 24px;
            margin-bottom: 16px;
        }
        .markdown-body h5 {
            color: #f0f6fc;
            font-size: 1.1em !important;
            margin-top: 24px;
            margin-bottom: 16px;
        }
        .markdown-body h6 {
            color: #f0f6fc;
            font-size: 1em !important;
            margin-top: 24px;
            margin-bottom: 16px;
        }
        .markdown-body a {
            color: #58a6ff;
        }
        .markdown-body a:hover {
            color: #79c0ff;
        }
        .markdown-body table th,
        .markdown-body table td {
            border: 1px solid #30363d;
        }
        .markdown-body table tr {
            background-color: #0d1117;
            border-top: 1px solid #30363d;
        }
        .markdown-body table tr:nth-child(2n) {
            background-color: #161b22;
        }
        .markdown-body code {
            background-color: rgba(110,118,129,0.4);
            color: #e6edf3;
        }
        .markdown-body pre {
            background-color: #161b22;
            border: 1px solid #30363d;
        }
        .markdown-body blockquote {
            color: #8b949e;
            border-left-color: #3b434b;
        }
        .markdown-body .highlight pre,
        .markdown-body pre {
            background-color: #161b22;
        }
        .doc-section {
            margin-bottom: 60px;
            border-bottom: 2px solid #30363d;
            padding-bottom: 40px;
        }
        .doc-section:last-child {
            border-bottom: none;
        }
        .back-to-top {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #1f6feb;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            text-decoration: none;
            display: none;
            z-index: 1000;
            border: 1px solid #30363d;
        }
        .back-to-top:hover {
            background: #58a6ff;
            color: white;
        }
        @media (max-width: 768px) {
            .sidebar {
                position: relative;
                width: 100%;
                height: auto;
                border-right: none;
                border-bottom: 1px solid #30363d;
            }
            .content {
                margin-left: 0;
            }
        }
        .toc {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 30px;
        }
        .toc h3 {
            margin-top: 0;
            color: #f0f6fc;
        }
        .toc ul {
            margin-left: 20px;
        }
        .toc a {
            color: #58a6ff;
            text-decoration: none;
        }
        .toc a:hover {
            text-decoration: underline;
        }
        /* Mermaid diagrams */
        .mermaid {
            text-align: center;
            margin: 20px 0;
            background: #161b22;
            padding: 20px;
            border-radius: 6px;
            border: 1px solid #30363d;
        }
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        ::-webkit-scrollbar-track {
            background: #161b22;
        }
        ::-webkit-scrollbar-thumb {
            background: #30363d;
            border-radius: 5px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #484f58;
        }
        /* Hide elements for search */
        .hidden {
            display: none !important;
        }
        /* Highlight search results */
        .highlight {
            background-color: #ffd33d;
            color: #24292e;
            padding: 2px;
            border-radius: 3px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'dark',
            themeVariables: {
                primaryColor: '#1f6feb',
                primaryTextColor: '#f0f6fc',
                primaryBorderColor: '#30363d',
                lineColor: '#58a6ff',
                secondaryColor: '#161b22',
                background: '#0d1117',
                mainBkg: '#161b22',
                textColor: '#c9d1d9'
            }
        });
    </script>
</head>
<body>
    <div class="container">
        <nav class="sidebar">
            <h1>NestJS GraphQL Microservices</h1>
            <div class="search-box">
                <input type="text" id="search-input" placeholder="Search documentation..." />
            </div>
            <h2>Documentation</h2><ul><li><a href="#README">Home</a></li></ul><h2>01 - Getting Started</h2><ul><li><a href="#01-getting-started-01-api-documentation">Api Documentation</a></li><li><a href="#01-getting-started-02-development-workflow">Development Workflow</a></li><li><a href="#01-getting-started-03-troubleshooting">Troubleshooting</a></li><li><a href="#01-getting-started-04-documentation-guide">Documentation Guide</a></li></ul><h2>02 - Architecture</h2><ul><li><a href="#02-architecture-01-graphql-federation-guide">Graphql Federation Guide</a></li><li><a href="#02-architecture-02-nx-monorepo-guide">Nx Monorepo Guide</a></li><li><a href="#02-architecture-03-architecture-overview">Architecture Overview</a></li></ul><h2>03 - Development</h2><ul><li><a href="#03-development-01-adding-new-service">Adding New Service</a></li><li><a href="#03-development-02-adding-new-library">Adding New Library</a></li><li><a href="#03-development-03-codegen-guide">Codegen Guide</a></li></ul><h2>04 - Best Practices</h2><ul><li><a href="#04-best-practices-01-graphql-best-practices">Graphql Best Practices</a></li><li><a href="#04-best-practices-02-codegen-best-practices">Codegen Best Practices</a></li><li><a href="#04-best-practices-03-security">Security</a></li></ul><h2>05 - Operations</h2><ul><li><a href="#05-operations-01-deployment">Deployment</a></li></ul>
            <div style="position: absolute; bottom: 20px; left: 20px; right: 20px; text-align: center; color: #8b949e; font-size: 12px; border-top: 1px solid #30363d; padding-top: 15px;">
                Author: Nicolas Rocchi
            </div>
        </nav>
        <main class="content">
            <div class="markdown-body">
                <div class="toc"><h3>Table of Contents</h3><ul><li><strong>Documentation</strong><ul><li><a href="#README">Home</a></li></ul></li><li><strong>01 - Getting Started</strong><ul><li><a href="#01-getting-started-01-api-documentation">Api Documentation</a></li><li><a href="#01-getting-started-02-development-workflow">Development Workflow</a></li><li><a href="#01-getting-started-03-troubleshooting">Troubleshooting</a></li><li><a href="#01-getting-started-04-documentation-guide">Documentation Guide</a></li></ul></li><li><strong>02 - Architecture</strong><ul><li><a href="#02-architecture-01-graphql-federation-guide">Graphql Federation Guide</a></li><li><a href="#02-architecture-02-nx-monorepo-guide">Nx Monorepo Guide</a></li><li><a href="#02-architecture-03-architecture-overview">Architecture Overview</a></li></ul></li><li><strong>03 - Development</strong><ul><li><a href="#03-development-01-adding-new-service">Adding New Service</a></li><li><a href="#03-development-02-adding-new-library">Adding New Library</a></li><li><a href="#03-development-03-codegen-guide">Codegen Guide</a></li></ul></li><li><strong>04 - Best Practices</strong><ul><li><a href="#04-best-practices-01-graphql-best-practices">Graphql Best Practices</a></li><li><a href="#04-best-practices-02-codegen-best-practices">Codegen Best Practices</a></li><li><a href="#04-best-practices-03-security">Security</a></li></ul></li><li><strong>05 - Operations</strong><ul><li><a href="#05-operations-01-deployment">Deployment</a></li></ul></li></ul></div><div id="README" class="doc-section"><h1 id="home">üìö Home</h1>
<p>Welcome to the NestJS GraphQL Microservices documentation. All documentation is organized by category with numerical prefixes for easy navigation.</p>
<h2 id="documentation-structure">üìÇ Documentation Structure</h2>
<pre><code>docs/
‚îú‚îÄ‚îÄ 01-getting-started/       # Introduction and basics
‚îú‚îÄ‚îÄ 02-architecture/          # System design and architecture
‚îú‚îÄ‚îÄ 03-development/           # Development guides
‚îú‚îÄ‚îÄ 04-best-practices/        # Standards and patterns
‚îî‚îÄ‚îÄ 05-operations/            # Deployment and operations
</code></pre>
<h2 id="documentation-by-category">üìñ Documentation by Category</h2>
<h3 id="01-getting-started">01 - Getting Started</h3>
<p>Essential documentation for new developers and project setup.</p>
<table>
<thead>
<tr>
<th>Document</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#01-getting-started-01-api-documentation">01 - API Documentation</a></td>
<td>Complete GraphQL API reference</td>
</tr>
<tr>
<td><a href="#01-getting-started-02-development-workflow">02 - Development Workflow</a></td>
<td>Daily development guide</td>
</tr>
<tr>
<td><a href="#01-getting-started-03-troubleshooting">03 - Troubleshooting</a></td>
<td>Common issues and solutions</td>
</tr>
</tbody></table>
<h3 id="02-architecture">02 - Architecture</h3>
<p>Technical architecture and system design documentation.</p>
<table>
<thead>
<tr>
<th>Document</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#02-architecture-01-graphql-federation-guide">01 - GraphQL Federation Guide</a></td>
<td>Distributed GraphQL architecture</td>
</tr>
<tr>
<td><a href="#02-architecture-02-nx-monorepo-guide">02 - NX Monorepo Guide</a></td>
<td>Monorepo management with NX</td>
</tr>
<tr>
<td><a href="#02-architecture-03-architecture-overview">03 - Architecture Overview</a></td>
<td>Visual architecture representations</td>
</tr>
</tbody></table>
<h3 id="03-development">03 - Development</h3>
<p>Step-by-step guides for development tasks.</p>
<table>
<thead>
<tr>
<th>Document</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#03-development-01-adding-new-service">01 - Adding a New Service</a></td>
<td>Create new microservices</td>
</tr>
<tr>
<td><a href="#03-development-02-adding-new-library">02 - Adding a New Library</a></td>
<td>Create shared libraries</td>
</tr>
<tr>
<td><a href="#03-development-03-codegen-guide">03 - Code Generation Guide</a></td>
<td>GraphQL code generation</td>
</tr>
</tbody></table>
<h3 id="04-best-practices">04 - Best Practices</h3>
<p>Coding standards, patterns, and security practices.</p>
<table>
<thead>
<tr>
<th>Document</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#04-best-practices-01-graphql-best-practices">01 - GraphQL Best Practices</a></td>
<td>GraphQL patterns and optimization</td>
</tr>
<tr>
<td><a href="#04-best-practices-02-codegen-best-practices">02 - Code Generation Best Practices</a></td>
<td>Codegen patterns and implementation</td>
</tr>
<tr>
<td><a href="#04-best-practices-03-security">03 - Security Guide</a></td>
<td>Security best practices</td>
</tr>
</tbody></table>
<h3 id="05-operations">05 - Operations</h3>
<p>Production deployment and operations documentation.</p>
<table>
<thead>
<tr>
<th>Document</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#05-operations-01-deployment">01 - Deployment Guide</a></td>
<td>Production deployment strategies</td>
</tr>
</tbody></table>
<h2 id="quick-start-paths">üöÄ Quick Start Paths</h2>
<h3 id="for-new-developers">For New Developers</h3>
<ol>
<li>Start with <strong><a href="#01-getting-started-01-api-documentation">01 - API Documentation</a></strong></li>
<li>Read <strong><a href="#01-getting-started-02-development-workflow">02 - Development Workflow</a></strong></li>
<li>Review <strong><a href="#02-architecture-01-graphql-federation-guide">01 - GraphQL Federation Guide</a></strong></li>
<li>Try <strong><a href="#03-development-01-adding-new-service">01 - Adding a New Service</a></strong></li>
</ol>
<h3 id="for-devops-engineers">For DevOps Engineers</h3>
<ol>
<li>Review <strong><a href="#05-operations-01-deployment">01 - Deployment Guide</a></strong></li>
<li>Check <strong><a href="#04-best-practices-03-security">03 - Security Guide</a></strong></li>
<li>Understand <strong><a href="#02-architecture-02-nx-monorepo-guide">02 - NX Monorepo Guide</a></strong></li>
</ol>
<h3 id="for-architects">For Architects</h3>
<ol>
<li>Study <strong><a href="#02-architecture-01-graphql-federation-guide">01 - GraphQL Federation Guide</a></strong></li>
<li>Review <strong><a href="#02-architecture-03-architecture-overview">03 - Architecture Overview</a></strong></li>
<li>Read <strong><a href="#04-best-practices-01-graphql-best-practices">01 - GraphQL Best Practices</a></strong></li>
</ol>
<h2 id="documentation-standards">üìã Documentation Standards</h2>
<h3 id="file-naming-convention">File Naming Convention</h3>
<p>All documentation files follow this pattern:</p>
<pre><code>[category-number]-[subcategory]/[document-number]-[document-name].md
</code></pre>
<p>Example: <code>01-getting-started/02-development-workflow.md</code></p>
<h3 id="adding-new-documentation">Adding New Documentation</h3>
<p>When adding new documentation:</p>
<ol>
<li><strong>Choose the right category</strong> - Place documents in the appropriate numbered folder</li>
<li><strong>Use sequential numbering</strong> - Add the next available number prefix</li>
<li><strong>Follow naming conventions</strong> - Use lowercase with hyphens</li>
<li><strong>Update this index</strong> - Add your document to the relevant section</li>
<li><strong>Cross-reference</strong> - Link to related documents</li>
</ol>
<h3 id="documentation-template">Documentation Template</h3>
<pre><code class="language-markdown"># Document Title

Brief description of what this document covers.

## Table of Contents

- [Overview](#overview)
- [Prerequisites](#prerequisites)
- [Main Content](#main-content)
- [Examples](#examples)
- [Next Steps](#next-steps)

## Overview

...

## Prerequisites

...

[content]

## Next Steps

- Link to related documentation
- Suggested follow-up tasks
</code></pre>
<h2 id="search-tips">üîç Search Tips</h2>
<ul>
<li>Use document numbers for quick navigation (e.g., &quot;01-02&quot; for Development Workflow)</li>
<li>Category folders group related topics</li>
<li>Architecture diagrams are in <code>02-architecture/03-architecture-overview.md</code></li>
<li>Security-related content is in <code>04-best-practices/03-security.md</code></li>
</ul>
<h2 id="maintenance">üìù Maintenance</h2>
<p>This documentation is maintained as part of the codebase. When making changes:</p>
<ul>
<li>Update documentation alongside code changes</li>
<li>Review and update examples</li>
<li>Ensure all links remain valid</li>
<li>Keep the numbering sequential</li>
</ul>
<hr>
<p><strong>Need help?</strong> Start with <strong><a href="#01-getting-started-03-troubleshooting">03 - Troubleshooting</a></strong> or check the <strong><a href="#01-getting-started-02-development-workflow">02 - Development Workflow</a></strong>.</p>
</div><div id="01-getting-started-01-api-documentation" class="doc-section"><h1 id="complete-api-documentation">Complete API Documentation</h1>
<p>This document provides a comprehensive reference for all GraphQL operations available in the NestJS GraphQL Microservices system.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#service-endpoints">Service Endpoints</a></li>
<li><a href="#users-service-api">Users Service API</a><ul>
<li><a href="#users-service-queries">Queries</a></li>
<li><a href="#users-service-mutations">Mutations</a></li>
<li><a href="#users-service-types">Types</a></li>
</ul>
</li>
<li><a href="#products-service-api">Products Service API</a><ul>
<li><a href="#products-service-queries">Queries</a></li>
<li><a href="#products-service-mutations">Mutations</a></li>
<li><a href="#products-service-types">Types</a></li>
</ul>
</li>
<li><a href="#federated-api-gateway">Federated API (Gateway)</a><ul>
<li><a href="#cross-service-queries">Cross-Service Queries</a></li>
<li><a href="#federation-examples">Federation Examples</a></li>
</ul>
</li>
<li><a href="#error-handling">Error Handling</a></li>
<li><a href="#authentication">Authentication</a></li>
</ul>
<h2 id="service-endpoints">Service Endpoints</h2>
<table>
<thead>
<tr>
<th>Service</th>
<th>GraphQL Endpoint</th>
<th>Playground URL</th>
</tr>
</thead>
<tbody><tr>
<td>API Gateway (Federated)</td>
<td><code>http://localhost:3000/graphql</code></td>
<td><a href="http://localhost:3000/graphql">http://localhost:3000/graphql</a></td>
</tr>
<tr>
<td>Users Service</td>
<td><code>http://localhost:3001/graphql</code></td>
<td><a href="http://localhost:3001/graphql">http://localhost:3001/graphql</a></td>
</tr>
<tr>
<td>Products Service</td>
<td><code>http://localhost:3002/graphql</code></td>
<td><a href="http://localhost:3002/graphql">http://localhost:3002/graphql</a></td>
</tr>
</tbody></table>
<h2 id="users-service-api">Users Service API</h2>
<h3 id="users-service-queries">Users Service Queries</h3>
<h4 id="get-all-users">Get All Users</h4>
<p>Retrieves a list of all users in the system.</p>
<pre><code class="language-graphql">query GetAllUsers {
  users {
    id
    email
    name
    createdAt
    updatedAt
  }
}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;users&quot;: [
      {
        &quot;id&quot;: &quot;550e8400-e29b-41d4-a716-446655440000&quot;,
        &quot;email&quot;: &quot;user@example.com&quot;,
        &quot;name&quot;: &quot;John Doe&quot;,
        &quot;createdAt&quot;: &quot;2024-01-01T00:00:00.000Z&quot;,
        &quot;updatedAt&quot;: &quot;2024-01-01T00:00:00.000Z&quot;
      }
    ]
  }
}
</code></pre>
<h4 id="get-user-by-id">Get User by ID</h4>
<p>Retrieves a specific user by their unique identifier.</p>
<pre><code class="language-graphql">query GetUser($id: String!) {
  user(id: $id) {
    id
    email
    name
    createdAt
    updatedAt
  }
}
</code></pre>
<p><strong>Variables:</strong></p>
<pre><code class="language-json">{
  &quot;id&quot;: &quot;550e8400-e29b-41d4-a716-446655440000&quot;
}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;user&quot;: {
      &quot;id&quot;: &quot;550e8400-e29b-41d4-a716-446655440000&quot;,
      &quot;email&quot;: &quot;user@example.com&quot;,
      &quot;name&quot;: &quot;John Doe&quot;,
      &quot;createdAt&quot;: &quot;2024-01-01T00:00:00.000Z&quot;,
      &quot;updatedAt&quot;: &quot;2024-01-01T00:00:00.000Z&quot;
    }
  }
}
</code></pre>
<h3 id="users-service-mutations">Users Service Mutations</h3>
<h4 id="create-user">Create User</h4>
<p>Creates a new user account with email and password.</p>
<pre><code class="language-graphql">mutation CreateUser($input: CreateUserInput!) {
  createUser(createUserInput: $input) {
    id
    email
    name
    createdAt
  }
}
</code></pre>
<p><strong>Variables:</strong></p>
<pre><code class="language-json">{
  &quot;input&quot;: {
    &quot;email&quot;: &quot;newuser@example.com&quot;,
    &quot;name&quot;: &quot;Jane Smith&quot;,
    &quot;password&quot;: &quot;securepassword123&quot;
  }
}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;createUser&quot;: {
      &quot;id&quot;: &quot;650e8400-e29b-41d4-a716-446655440001&quot;,
      &quot;email&quot;: &quot;newuser@example.com&quot;,
      &quot;name&quot;: &quot;Jane Smith&quot;,
      &quot;createdAt&quot;: &quot;2024-01-02T00:00:00.000Z&quot;
    }
  }
}
</code></pre>
<h4 id="update-user">Update User</h4>
<p>Updates an existing user&#39;s information.</p>
<pre><code class="language-graphql">mutation UpdateUser($input: UpdateUserInput!) {
  updateUser(updateUserInput: $input) {
    id
    email
    name
    updatedAt
  }
}
</code></pre>
<p><strong>Variables:</strong></p>
<pre><code class="language-json">{
  &quot;input&quot;: {
    &quot;id&quot;: &quot;550e8400-e29b-41d4-a716-446655440000&quot;,
    &quot;name&quot;: &quot;John Updated&quot;,
    &quot;email&quot;: &quot;newemail@example.com&quot;
  }
}
</code></pre>
<p><strong>Note:</strong> All fields except <code>id</code> are optional in the update input.</p>
<h4 id="remove-user">Remove User</h4>
<p>Deletes a user from the system.</p>
<pre><code class="language-graphql">mutation RemoveUser($id: String!) {
  removeUser(id: $id) {
    id
    email
    name
  }
}
</code></pre>
<p><strong>Variables:</strong></p>
<pre><code class="language-json">{
  &quot;id&quot;: &quot;550e8400-e29b-41d4-a716-446655440000&quot;
}
</code></pre>
<h3 id="users-service-types">Users Service Types</h3>
<h4 id="user-type">User Type</h4>
<pre><code class="language-graphql">type User {
  id: ID!
  email: String!
  name: String!
  password: String! # Hashed, not returned in queries
  createdAt: DateTime!
  updatedAt: DateTime!
  products: [Product!]! # Available through federation
}
</code></pre>
<h4 id="createuserinput">CreateUserInput</h4>
<pre><code class="language-graphql">input CreateUserInput {
  email: String!
  name: String!
  password: String!
}
</code></pre>
<h4 id="updateuserinput">UpdateUserInput</h4>
<pre><code class="language-graphql">input UpdateUserInput {
  id: String!
  email: String
  name: String
  password: String
}
</code></pre>
<h2 id="products-service-api">Products Service API</h2>
<h3 id="products-service-queries">Products Service Queries</h3>
<h4 id="get-all-products">Get All Products</h4>
<p>Retrieves all products in the catalog.</p>
<pre><code class="language-graphql">query GetAllProducts {
  products {
    id
    name
    description
    price
    sku
    stock
    userId
    createdAt
    updatedAt
  }
}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;products&quot;: [
      {
        &quot;id&quot;: &quot;750e8400-e29b-41d4-a716-446655440002&quot;,
        &quot;name&quot;: &quot;Laptop Pro&quot;,
        &quot;description&quot;: &quot;High-performance laptop&quot;,
        &quot;price&quot;: 1299.99,
        &quot;sku&quot;: &quot;LAPTOP-001&quot;,
        &quot;stock&quot;: 50,
        &quot;userId&quot;: &quot;550e8400-e29b-41d4-a716-446655440000&quot;,
        &quot;createdAt&quot;: &quot;2024-01-01T00:00:00.000Z&quot;,
        &quot;updatedAt&quot;: &quot;2024-01-01T00:00:00.000Z&quot;
      }
    ]
  }
}
</code></pre>
<h4 id="get-product-by-id">Get Product by ID</h4>
<p>Retrieves a specific product by its identifier.</p>
<pre><code class="language-graphql">query GetProduct($id: String!) {
  product(id: $id) {
    id
    name
    description
    price
    sku
    stock
    userId
    createdAt
    updatedAt
  }
}
</code></pre>
<p><strong>Variables:</strong></p>
<pre><code class="language-json">{
  &quot;id&quot;: &quot;750e8400-e29b-41d4-a716-446655440002&quot;
}
</code></pre>
<h4 id="get-products-by-user">Get Products by User</h4>
<p>Retrieves all products owned by a specific user.</p>
<pre><code class="language-graphql">query GetProductsByUser($userId: String!) {
  productsByUser(userId: $userId) {
    id
    name
    description
    price
    sku
    stock
    createdAt
  }
}
</code></pre>
<p><strong>Variables:</strong></p>
<pre><code class="language-json">{
  &quot;userId&quot;: &quot;550e8400-e29b-41d4-a716-446655440000&quot;
}
</code></pre>
<h3 id="products-service-mutations">Products Service Mutations</h3>
<h4 id="create-product">Create Product</h4>
<p>Creates a new product in the catalog.</p>
<pre><code class="language-graphql">mutation CreateProduct($input: CreateProductInput!) {
  createProduct(createProductInput: $input) {
    id
    name
    description
    price
    sku
    stock
    userId
    createdAt
  }
}
</code></pre>
<p><strong>Variables:</strong></p>
<pre><code class="language-json">{
  &quot;input&quot;: {
    &quot;name&quot;: &quot;Smartphone X&quot;,
    &quot;description&quot;: &quot;Latest model smartphone with advanced features&quot;,
    &quot;price&quot;: 999.99,
    &quot;sku&quot;: &quot;PHONE-X-001&quot;,
    &quot;stock&quot;: 100,
    &quot;userId&quot;: &quot;550e8400-e29b-41d4-a716-446655440000&quot;
  }
}
</code></pre>
<h4 id="update-product">Update Product</h4>
<p>Updates an existing product&#39;s information.</p>
<pre><code class="language-graphql">mutation UpdateProduct($input: UpdateProductInput!) {
  updateProduct(updateProductInput: $input) {
    id
    name
    description
    price
    sku
    stock
    updatedAt
  }
}
</code></pre>
<p><strong>Variables:</strong></p>
<pre><code class="language-json">{
  &quot;input&quot;: {
    &quot;id&quot;: &quot;750e8400-e29b-41d4-a716-446655440002&quot;,
    &quot;price&quot;: 899.99,
    &quot;stock&quot;: 75,
    &quot;description&quot;: &quot;Updated description&quot;
  }
}
</code></pre>
<h4 id="remove-product">Remove Product</h4>
<p>Deletes a product from the catalog.</p>
<pre><code class="language-graphql">mutation RemoveProduct($id: String!) {
  removeProduct(id: $id) {
    id
    name
    sku
  }
}
</code></pre>
<p><strong>Variables:</strong></p>
<pre><code class="language-json">{
  &quot;id&quot;: &quot;750e8400-e29b-41d4-a716-446655440002&quot;
}
</code></pre>
<h3 id="products-service-types">Products Service Types</h3>
<h4 id="product-type">Product Type</h4>
<pre><code class="language-graphql">type Product {
  id: ID!
  name: String!
  description: String
  price: Float!
  sku: String!
  stock: Int!
  userId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User! # Available through federation
}
</code></pre>
<h4 id="createproductinput">CreateProductInput</h4>
<pre><code class="language-graphql">input CreateProductInput {
  name: String!
  description: String
  price: Float!
  sku: String!
  stock: Int!
  userId: String!
}
</code></pre>
<h4 id="updateproductinput">UpdateProductInput</h4>
<pre><code class="language-graphql">input UpdateProductInput {
  id: String!
  name: String
  description: String
  price: Float
  sku: String
  stock: Int
  userId: String
}
</code></pre>
<h2 id="federated-api-gateway">Federated API (Gateway)</h2>
<p>The API Gateway provides a unified GraphQL endpoint that combines all microservices through Apollo Federation.</p>
<h3 id="cross-service-queries">Cross-Service Queries</h3>
<h4 id="users-with-their-products">Users with Their Products</h4>
<p>This query demonstrates federation by fetching users and their associated products in a single request.</p>
<pre><code class="language-graphql">query GetUsersWithTheirProducts {
  users {
    id
    email
    name
    products {
      id
      name
      price
      stock
      sku
    }
  }
}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;users&quot;: [
      {
        &quot;id&quot;: &quot;550e8400-e29b-41d4-a716-446655440000&quot;,
        &quot;email&quot;: &quot;user@example.com&quot;,
        &quot;name&quot;: &quot;John Doe&quot;,
        &quot;products&quot;: [
          {
            &quot;id&quot;: &quot;750e8400-e29b-41d4-a716-446655440002&quot;,
            &quot;name&quot;: &quot;Laptop Pro&quot;,
            &quot;price&quot;: 1299.99,
            &quot;stock&quot;: 50,
            &quot;sku&quot;: &quot;LAPTOP-001&quot;
          }
        ]
      }
    ]
  }
}
</code></pre>
<h4 id="products-with-owner-information">Products with Owner Information</h4>
<p>Fetches products along with their owner&#39;s details.</p>
<pre><code class="language-graphql">query GetProductsWithOwners {
  products {
    id
    name
    description
    price
    stock
    user {
      id
      email
      name
    }
  }
}
</code></pre>
<h3 id="federation-examples">Federation Examples</h3>
<h4 id="complex-federated-query">Complex Federated Query</h4>
<p>This example shows how to leverage federation for complex data requirements:</p>
<pre><code class="language-graphql">query ComplexFederatedQuery($userId: String!, $minPrice: Float) {
  # Get specific user with all their products
  user(id: $userId) {
    id
    email
    name
    createdAt
    products {
      id
      name
      price
      stock
      description
    }
  }
  
  # Get all products above a certain price
  products {
    id
    name
    price
    stock
    user {
      id
      name
      email
    }
  }
}
</code></pre>
<p><strong>Variables:</strong></p>
<pre><code class="language-json">{
  &quot;userId&quot;: &quot;550e8400-e29b-41d4-a716-446655440000&quot;,
  &quot;minPrice&quot;: 100.00
}
</code></pre>
<h4 id="nested-federation-query">Nested Federation Query</h4>
<p>Demonstrates deep nesting capabilities:</p>
<pre><code class="language-graphql">query DeepFederationQuery {
  users {
    id
    name
    email
    products {
      id
      name
      price
      description
      user {
        id
        name
        email
      }
    }
  }
}
</code></pre>
<h2 id="error-handling">Error Handling</h2>
<p>The API uses standard GraphQL error responses with custom exception types:</p>
<h3 id="common-error-responses">Common Error Responses</h3>
<h4 id="resource-not-found">Resource Not Found</h4>
<pre><code class="language-json">{
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;User with ID &#39;invalid-id&#39; not found&quot;,
      &quot;extensions&quot;: {
        &quot;code&quot;: &quot;RESOURCE_NOT_FOUND&quot;,
        &quot;statusCode&quot;: 404
      }
    }
  ]
}
</code></pre>
<h4 id="invalid-input">Invalid Input</h4>
<pre><code class="language-json">{
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;Invalid UUID format&quot;,
      &quot;extensions&quot;: {
        &quot;code&quot;: &quot;INVALID_FORMAT&quot;,
        &quot;statusCode&quot;: 400
      }
    }
  ]
}
</code></pre>
<h4 id="validation-error">Validation Error</h4>
<pre><code class="language-json">{
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;Validation failed&quot;,
      &quot;extensions&quot;: {
        &quot;code&quot;: &quot;BAD_USER_INPUT&quot;,
        &quot;statusCode&quot;: 400,
        &quot;validationErrors&quot;: [
          {
            &quot;field&quot;: &quot;email&quot;,
            &quot;message&quot;: &quot;Invalid email format&quot;
          }
        ]
      }
    }
  ]
}
</code></pre>
<h3 id="exception-types">Exception Types</h3>
<ul>
<li><code>ResourceNotFoundException</code> - When a requested resource doesn&#39;t exist</li>
<li><code>InvalidFormatException</code> - When input format is invalid (e.g., UUID)</li>
<li><code>ValidationException</code> - When input validation fails</li>
<li><code>ConflictException</code> - When operation would create a conflict (e.g., duplicate email)</li>
</ul>
<h2 id="authentication">Authentication</h2>
<blockquote>
<p><strong>Note:</strong> Authentication is currently in development on the <code>feature/authentication</code> branch.</p>
</blockquote>
<h3 id="planned-authentication-features">Planned Authentication Features</h3>
<ol>
<li><p><strong>JWT Token Authentication</strong></p>
<ul>
<li>Access tokens with configurable expiration</li>
<li>Refresh token rotation</li>
<li>Secure token storage recommendations</li>
</ul>
</li>
<li><p><strong>Role-Based Access Control (RBAC)</strong></p>
<ul>
<li>User roles: Admin, User, Guest</li>
<li>Permission-based field resolution</li>
<li>Query/Mutation level authorization</li>
</ul>
</li>
<li><p><strong>Protected Operations</strong></p>
<ul>
<li>Public queries (read operations)</li>
<li>Protected mutations (require authentication)</li>
<li>Admin-only operations</li>
</ul>
</li>
</ol>
<h3 id="future-authentication-examples">Future Authentication Examples</h3>
<pre><code class="language-graphql"># Login mutation (coming soon)
mutation Login($credentials: LoginInput!) {
  login(credentials: $credentials) {
    accessToken
    refreshToken
    user {
      id
      email
      name
      role
    }
  }
}

# Protected query with auth header
query GetMyProfile {
  me {
    id
    email
    name
    products {
      id
      name
    }
  }
}
</code></pre>
<h2 id="best-practices">Best Practices</h2>
<h3 id="query-optimization">Query Optimization</h3>
<ol>
<li><p><strong>Request only needed fields</strong></p>
<pre><code class="language-graphql"># Good - specific fields
query { users { id name } }

# Avoid - requesting everything
query { users { id name email createdAt updatedAt } }
</code></pre>
</li>
<li><p><strong>Use variables for dynamic values</strong></p>
<pre><code class="language-graphql"># Good
query GetUser($id: String!) {
  user(id: $id) { name }
}

# Avoid
query {
  user(id: &quot;hardcoded-id&quot;) { name }
}
</code></pre>
</li>
<li><p><strong>Batch related queries</strong></p>
<pre><code class="language-graphql"># Good - single request
query {
  user(id: $id) {
    name
    products { name price }
  }
}

# Avoid - multiple requests
query { user(id: $id) { name } }
query { productsByUser(userId: $id) { name price } }
</code></pre>
</li>
</ol>
<h3 id="mutation-patterns">Mutation Patterns</h3>
<ol>
<li><p><strong>Return updated data</strong></p>
<pre><code class="language-graphql">mutation UpdateUser($input: UpdateUserInput!) {
  updateUser(updateUserInput: $input) {
    id
    name
    email
    updatedAt
  }
}
</code></pre>
</li>
<li><p><strong>Handle errors gracefully</strong></p>
<ul>
<li>Check for validation errors</li>
<li>Handle not found scenarios</li>
<li>Implement proper retry logic</li>
</ul>
</li>
<li><p><strong>Use descriptive names</strong></p>
<ul>
<li>Clear mutation names: <code>createUser</code>, not <code>newUser</code></li>
<li>Consistent naming: <code>removeUser</code>, not <code>deleteUser</code> in one service and <code>removeProduct</code> in another</li>
</ul>
</li>
</ol>
</div><div id="01-getting-started-02-development-workflow" class="doc-section"><h1 id="development-workflow-guide">Development Workflow Guide</h1>
<p>This guide covers the day-to-day development workflow for working with the NestJS GraphQL Microservices project.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#getting-started">Getting Started</a></li>
<li><a href="#daily-development-flow">Daily Development Flow</a></li>
<li><a href="#feature-development">Feature Development</a></li>
<li><a href="#testing-workflow">Testing Workflow</a></li>
<li><a href="#code-review-process">Code Review Process</a></li>
<li><a href="#git-workflow">Git Workflow</a></li>
<li><a href="#development-best-practices">Development Best Practices</a></li>
<li><a href="#debugging-techniques">Debugging Techniques</a></li>
<li><a href="#performance-optimization">Performance Optimization</a></li>
<li><a href="#team-collaboration">Team Collaboration</a></li>
</ul>
<h2 id="getting-started">Getting Started</h2>
<h3 id="first-day-setup">First Day Setup</h3>
<pre><code class="language-bash"># 1. Clone the repository
git clone https://github.com/your-org/nestjs-graphql-microservices
cd nestjs-graphql-microservices

# 2. Install dependencies
pnpm install

# 3. Setup environment
cp .env.example .env
# Edit .env files for each service

# 4. Initialize the project
pnpm project:init

# 5. Start development
pnpm dev

# 6. Verify everything works
curl http://localhost:3000/graphql
</code></pre>
<h3 id="ide-setup">IDE Setup</h3>
<h4 id="vs-code-extensions">VS Code Extensions</h4>
<pre><code class="language-json">// .vscode/extensions.json
{
  &quot;recommendations&quot;: [
    &quot;dbaeumer.vscode-eslint&quot;,
    &quot;esbenp.prettier-vscode&quot;,
    &quot;prisma.prisma&quot;,
    &quot;graphql.vscode-graphql&quot;,
    &quot;nrwl.angular-console&quot;,
    &quot;firsttris.vscode-jest-runner&quot;,
    &quot;ms-vscode.vscode-typescript-tslint-plugin&quot;,
    &quot;christian-kohler.path-intellisense&quot;,
    &quot;mikestead.dotenv&quot;
  ]
}
</code></pre>
<h4 id="vs-code-settings">VS Code Settings</h4>
<pre><code class="language-json">// .vscode/settings.json
{
  &quot;editor.formatOnSave&quot;: true,
  &quot;editor.codeActionsOnSave&quot;: {
    &quot;source.fixAll.eslint&quot;: true
  },
  &quot;typescript.tsdk&quot;: &quot;node_modules/typescript/lib&quot;,
  &quot;typescript.enablePromptUseWorkspaceTsdk&quot;: true,
  &quot;files.exclude&quot;: {
    &quot;**/.git&quot;: true,
    &quot;**/.DS_Store&quot;: true,
    &quot;**/node_modules&quot;: true,
    &quot;dist&quot;: true,
    &quot;.nx&quot;: true
  },
  &quot;jest.autoRun&quot;: {
    &quot;watch&quot;: false,
    &quot;onSave&quot;: &quot;test-file&quot;
  }
}
</code></pre>
<h2 id="daily-development-flow">Daily Development Flow</h2>
<h3 id="morning-routine">Morning Routine</h3>
<pre><code class="language-bash"># 1. Update your local main branch
git checkout main
git pull origin main

# 2. Create/checkout your feature branch
git checkout -b feature/your-feature-name

# 3. Ensure dependencies are up to date
pnpm install

# 4. Start all services
pnpm dev

# 5. Run code generation (if schemas changed)
pnpm codegen

# 6. Check for any breaking changes
pnpm test:affected
</code></pre>
<h3 id="development-cycle">Development Cycle</h3>
<div class="mermaid">graph LR
    A[Write Code] --> B[Run Tests]
    B --> C[Check Linting]
    C --> D[Test Locally]
    D --> E{All Good?}
    E -->|No| A
    E -->|Yes| F[Commit]
    F --> G[Push]
    G --> H[Create PR]
</div>

<h3 id="before-committing">Before Committing</h3>
<pre><code class="language-bash"># 1. Format code
pnpm nx format:write

# 2. Run linting
pnpm lint

# 3. Run tests
pnpm test:affected

# 4. Build affected projects
pnpm nx affected:build

# 5. Run type checking
pnpm nx affected --target=typecheck
</code></pre>
<h2 id="feature-development">Feature Development</h2>
<h3 id="creating-a-new-feature">Creating a New Feature</h3>
<h4 id="1-plan-the-feature">1. Plan the Feature</h4>
<pre><code class="language-markdown">## Feature: User Favorites

### Requirements
- Users can favorite products
- View list of favorited products
- Maximum 100 favorites per user

### Technical Design
- New `Favorite` entity
- Many-to-many relationship
- GraphQL mutations: addFavorite, removeFavorite
- GraphQL query: myFavorites
</code></pre>
<h4 id="2-create-feature-branch">2. Create Feature Branch</h4>
<pre><code class="language-bash">git checkout -b feature/user-favorites
</code></pre>
<h4 id="3-database-schema">3. Database Schema</h4>
<pre><code class="language-prisma">// apps/products-service/prisma/schema.prisma
model Favorite {
  id        String   @id @default(uuid())
  userId    String
  productId String
  product   Product  @relation(fields: [productId], references: [id])
  createdAt DateTime @default(now())
  
  @@unique([userId, productId])
  @@index([userId])
}
</code></pre>
<h4 id="4-run-migration">4. Run Migration</h4>
<pre><code class="language-bash"># Generate migration
cd apps/products-service
npx prisma migrate dev --name add_favorites

# Generate Prisma client
pnpm prisma:generate:products
</code></pre>
<h4 id="5-update-graphql-schema">5. Update GraphQL Schema</h4>
<pre><code class="language-typescript">// apps/products-service/src/app/favorites/entities/favorite.entity.ts
@ObjectType()
export class Favorite {
  @Field(() =&gt; ID)
  id: string

  @Field()
  userId: string

  @Field()
  productId: string

  @Field(() =&gt; Product)
  product?: Product

  @Field()
  createdAt: Date
}
</code></pre>
<h4 id="6-implement-service">6. Implement Service</h4>
<pre><code class="language-typescript">// apps/products-service/src/app/favorites/favorites.service.ts
@Injectable()
export class FavoritesService {
  constructor(private prisma: PrismaService) {}

  async addFavorite(userId: string, productId: string): Promise&lt;Favorite&gt; {
    // Check limit
    const count = await this.prisma.favorite.count({ where: { userId } })
    if (count &gt;= 100) {
      throw new BadRequestException(&#39;Maximum favorites limit reached&#39;)
    }

    return this.prisma.favorite.create({
      data: { userId, productId },
      include: { product: true }
    })
  }

  async getUserFavorites(userId: string): Promise&lt;Favorite[]&gt; {
    return this.prisma.favorite.findMany({
      where: { userId },
      include: { product: true },
      orderBy: { createdAt: &#39;desc&#39; }
    })
  }
}
</code></pre>
<h4 id="7-create-resolver">7. Create Resolver</h4>
<pre><code class="language-typescript">// apps/products-service/src/app/favorites/favorites.resolver.ts
@Resolver(() =&gt; Favorite)
export class FavoritesResolver {
  constructor(private favoritesService: FavoritesService) {}

  @Mutation(() =&gt; Favorite)
  async addFavorite(
    @Args(&#39;productId&#39;) productId: string,
    @CurrentUser() user: User
  ): Promise&lt;Favorite&gt; {
    return this.favoritesService.addFavorite(user.id, productId)
  }

  @Query(() =&gt; [Favorite])
  async myFavorites(@CurrentUser() user: User): Promise&lt;Favorite[]&gt; {
    return this.favoritesService.getUserFavorites(user.id)
  }
}
</code></pre>
<h4 id="8-write-tests">8. Write Tests</h4>
<pre><code class="language-typescript">// apps/products-service/src/app/favorites/favorites.service.spec.ts
describe(&#39;FavoritesService&#39;, () =&gt; {
  let service: FavoritesService
  let prisma: MockPrismaService

  beforeEach(async () =&gt; {
    const module = await Test.createTestingModule({
      providers: [
        FavoritesService,
        { provide: PrismaService, useValue: mockPrismaService() }
      ]
    }).compile()

    service = module.get(FavoritesService)
    prisma = module.get(PrismaService)
  })

  describe(&#39;addFavorite&#39;, () =&gt; {
    it(&#39;should add a favorite&#39;, async () =&gt; {
      const userId = &#39;user-123&#39;
      const productId = &#39;product-456&#39;
      
      prisma.favorite.count.mockResolvedValue(5)
      prisma.favorite.create.mockResolvedValue({
        id: &#39;fav-1&#39;,
        userId,
        productId,
        createdAt: new Date()
      })

      const result = await service.addFavorite(userId, productId)
      
      expect(result.userId).toBe(userId)
      expect(result.productId).toBe(productId)
    })

    it(&#39;should throw error when limit exceeded&#39;, async () =&gt; {
      prisma.favorite.count.mockResolvedValue(100)
      
      await expect(
        service.addFavorite(&#39;user-123&#39;, &#39;product-456&#39;)
      ).rejects.toThrow(&#39;Maximum favorites limit reached&#39;)
    })
  })
})
</code></pre>
<h4 id="9-update-documentation">9. Update Documentation</h4>
<pre><code class="language-graphql"># libs/codegen/src/operations/favorites.graphql
mutation AddFavorite($productId: String!) {
  addFavorite(productId: $productId) {
    id
    product {
      id
      name
      price
    }
    createdAt
  }
}

query MyFavorites {
  myFavorites {
    id
    product {
      id
      name
      price
      stock
    }
    createdAt
  }
}
</code></pre>
<h4 id="10-generate-types">10. Generate Types</h4>
<pre><code class="language-bash">pnpm codegen
</code></pre>
<h2 id="testing-workflow">Testing Workflow</h2>
<h3 id="test-pyramid">Test Pyramid</h3>
<pre><code>         /\
        /  \  E2E Tests (Few)
       /    \
      /------\  Integration Tests (Some)
     /        \
    /----------\  Unit Tests (Many)
</code></pre>
<h3 id="running-tests">Running Tests</h3>
<pre><code class="language-bash"># Unit tests for a specific service
nx test users-service

# Integration tests
nx e2e users-service-e2e

# Test with coverage
nx test users-service --coverage

# Test in watch mode
nx test users-service --watch

# Test only affected by changes
nx affected:test
</code></pre>
<h3 id="writing-good-tests">Writing Good Tests</h3>
<pre><code class="language-typescript">describe(&#39;UsersService&#39;, () =&gt; {
  let service: UsersService

  // Group related tests
  describe(&#39;findAll&#39;, () =&gt; {
    it(&#39;should return paginated results&#39;, async () =&gt; {
      // Arrange
      const mockUsers = createMockUsers(5)
      
      // Act
      const result = await service.findAll({ limit: 10, offset: 0 })
      
      // Assert
      expect(result.items).toHaveLength(5)
      expect(result.total).toBe(5)
      expect(result.hasMore).toBe(false)
    })

    it(&#39;should apply filters correctly&#39;, async () =&gt; {
      // Test specific behavior
    })
  })

  // Test error cases
  describe(&#39;error handling&#39;, () =&gt; {
    it(&#39;should throw NotFoundException for invalid ID&#39;, async () =&gt; {
      await expect(service.findOne(&#39;invalid-id&#39;))
        .rejects
        .toThrow(NotFoundException)
    })
  })
})
</code></pre>
<h3 id="e2e-testing">E2E Testing</h3>
<pre><code class="language-typescript">describe(&#39;Users API (e2e)&#39;, () =&gt; {
  let app: INestApplication

  beforeAll(async () =&gt; {
    const moduleFixture = await Test.createTestingModule({
      imports: [AppModule],
    }).compile()

    app = moduleFixture.createNestApplication()
    await app.init()
  })

  describe(&#39;GraphQL Queries&#39;, () =&gt; {
    it(&#39;should get users&#39;, () =&gt; {
      return request(app.getHttpServer())
        .post(&#39;/graphql&#39;)
        .send({
          query: `
            query {
              users {
                id
                name
                email
              }
            }
          `
        })
        .expect(200)
        .expect(res =&gt; {
          expect(res.body.data.users).toBeDefined()
          expect(res.body.data.users).toBeInstanceOf(Array)
        })
    })
  })

  afterAll(async () =&gt; {
    await app.close()
  })
})
</code></pre>
<h2 id="code-review-process">Code Review Process</h2>
<h3 id="creating-a-pull-request">Creating a Pull Request</h3>
<pre><code class="language-markdown">## Description
Brief description of what this PR does

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Breaking change
- [ ] Documentation update

## How Has This Been Tested?
- [ ] Unit tests
- [ ] Integration tests
- [ ] Manual testing

## Checklist
- [ ] My code follows the style guidelines
- [ ] I have performed a self-review
- [ ] I have commented my code where necessary
- [ ] I have made corresponding changes to the documentation
- [ ] My changes generate no new warnings
- [ ] I have added tests that prove my fix/feature works
- [ ] New and existing unit tests pass locally
- [ ] Any dependent changes have been merged
</code></pre>
<h3 id="code-review-checklist">Code Review Checklist</h3>
<p>For reviewers:</p>
<ul>
<li><input disabled="" type="checkbox"> <strong>Logic</strong>: Is the logic correct and efficient?</li>
<li><input disabled="" type="checkbox"> <strong>Tests</strong>: Are there adequate tests?</li>
<li><input disabled="" type="checkbox"> <strong>Security</strong>: Any security concerns?</li>
<li><input disabled="" type="checkbox"> <strong>Performance</strong>: Any performance issues?</li>
<li><input disabled="" type="checkbox"> <strong>Standards</strong>: Does it follow our standards?</li>
<li><input disabled="" type="checkbox"> <strong>Documentation</strong>: Is it properly documented?</li>
<li><input disabled="" type="checkbox"> <strong>Types</strong>: Are TypeScript types correct?</li>
<li><input disabled="" type="checkbox"> <strong>Error Handling</strong>: Are errors handled properly?</li>
</ul>
<h3 id="handling-feedback">Handling Feedback</h3>
<pre><code class="language-bash"># Make requested changes
git add .
git commit -m &quot;fix: address PR feedback&quot;

# Or amend if small changes
git add .
git commit --amend --no-edit

# Force push to your branch
git push --force-with-lease origin feature/your-feature
</code></pre>
<h2 id="git-workflow">Git Workflow</h2>
<h3 id="branch-naming">Branch Naming</h3>
<pre><code>feature/user-authentication
bugfix/login-error-handling
hotfix/security-patch
chore/update-dependencies
docs/api-documentation
</code></pre>
<h3 id="commit-messages">Commit Messages</h3>
<p>Follow conventional commits:</p>
<pre><code>feat: add user favorites feature
fix: resolve race condition in auth service
docs: update API documentation
style: format code with prettier
refactor: extract validation logic
test: add tests for favorites service
chore: update dependencies
perf: optimize database queries
</code></pre>
<h3 id="git-flow">Git Flow</h3>
<pre><code class="language-bash"># 1. Create feature branch
git checkout -b feature/new-feature

# 2. Make changes and commit
git add .
git commit -m &quot;feat: add new feature&quot;

# 3. Keep branch updated
git fetch origin
git rebase origin/main

# 4. Push branch
git push origin feature/new-feature

# 5. Create PR and merge

# 6. Clean up
git checkout main
git pull origin main
git branch -d feature/new-feature
</code></pre>
<h3 id="handling-conflicts">Handling Conflicts</h3>
<pre><code class="language-bash"># 1. Update main
git checkout main
git pull origin main

# 2. Rebase your branch
git checkout feature/your-feature
git rebase main

# 3. Resolve conflicts
# Edit conflicted files
git add .
git rebase --continue

# 4. Force push
git push --force-with-lease origin feature/your-feature
</code></pre>
<h2 id="development-best-practices">Development Best Practices</h2>
<h3 id="code-organization">Code Organization</h3>
<pre><code class="language-typescript">// Good: Single responsibility
@Injectable()
export class UserValidationService {
  validateEmail(email: string): boolean { }
  validatePassword(password: string): boolean { }
}

// Bad: Too many responsibilities
@Injectable()
export class UserService {
  validateEmail() { }
  sendEmail() { }
  hashPassword() { }
  createUser() { }
  updateProfile() { }
}
</code></pre>
<h3 id="error-handling">Error Handling</h3>
<pre><code class="language-typescript">// Good: Specific error handling
try {
  const user = await this.usersService.findOne(id)
  if (!user) {
    throw new NotFoundException(`User with ID ${id} not found`)
  }
  return user
} catch (error) {
  if (error instanceof NotFoundException) {
    throw error
  }
  this.logger.error(&#39;Unexpected error finding user&#39;, error)
  throw new InternalServerErrorException(&#39;Failed to fetch user&#39;)
}

// Bad: Generic error handling
try {
  return await this.usersService.findOne(id)
} catch (error) {
  throw new Error(&#39;Something went wrong&#39;)
}
</code></pre>
<h3 id="performance-considerations">Performance Considerations</h3>
<pre><code class="language-typescript">// Good: Batch operations
const userIds = products.map(p =&gt; p.userId)
const users = await this.usersService.findByIds(userIds)
const userMap = new Map(users.map(u =&gt; [u.id, u]))

// Bad: N+1 queries
for (const product of products) {
  const user = await this.usersService.findOne(product.userId)
  product.user = user
}
</code></pre>
<h2 id="debugging-techniques">Debugging Techniques</h2>
<h3 id="using-vs-code-debugger">Using VS Code Debugger</h3>
<pre><code class="language-json">// .vscode/launch.json
{
  &quot;version&quot;: &quot;0.2.0&quot;,
  &quot;configurations&quot;: [
    {
      &quot;type&quot;: &quot;node&quot;,
      &quot;request&quot;: &quot;launch&quot;,
      &quot;name&quot;: &quot;Debug Users Service&quot;,
      &quot;runtimeExecutable&quot;: &quot;pnpm&quot;,
      &quot;runtimeArgs&quot;: [&quot;nx&quot;, &quot;serve&quot;, &quot;users-service&quot;],
      &quot;console&quot;: &quot;integratedTerminal&quot;,
      &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;
    }
  ]
}
</code></pre>
<h3 id="logging-strategy">Logging Strategy</h3>
<pre><code class="language-typescript">@Injectable()
export class LoggerService {
  private logger = new Logger()

  logRequest(method: string, args: any) {
    this.logger.log(`${method} called with args: ${JSON.stringify(args)}`)
  }

  logError(method: string, error: Error) {
    this.logger.error(`${method} failed: ${error.message}`, error.stack)
  }

  logPerformance(method: string, duration: number) {
    if (duration &gt; 1000) {
      this.logger.warn(`${method} took ${duration}ms`)
    }
  }
}

// Usage
@Injectable()
export class UsersService {
  async findOne(id: string) {
    const start = Date.now()
    this.logger.logRequest(&#39;findOne&#39;, { id })
    
    try {
      const user = await this.prisma.user.findUnique({ where: { id } })
      return user
    } catch (error) {
      this.logger.logError(&#39;findOne&#39;, error)
      throw error
    } finally {
      this.logger.logPerformance(&#39;findOne&#39;, Date.now() - start)
    }
  }
}
</code></pre>
<h3 id="graphql-query-debugging">GraphQL Query Debugging</h3>
<pre><code class="language-typescript">// Enable GraphQL playground query tracing
GraphQLModule.forRoot({
  playground: {
    settings: {
      &#39;request.credentials&#39;: &#39;include&#39;,
      &#39;tracing.hideTracingResponse&#39;: false
    }
  },
  debug: true,
  tracing: true
})
</code></pre>
<h2 id="performance-optimization">Performance Optimization</h2>
<h3 id="query-optimization">Query Optimization</h3>
<pre><code class="language-typescript">// Use field selection
async findAll(fields?: string[]) {
  return this.prisma.user.findMany({
    select: fields ? 
      Object.fromEntries(fields.map(f =&gt; [f, true])) : 
      undefined
  })
}

// Use pagination
async findPaginated(page: number, limit: number) {
  const [items, total] = await Promise.all([
    this.prisma.user.findMany({
      skip: (page - 1) * limit,
      take: limit
    }),
    this.prisma.user.count()
  ])

  return {
    items,
    total,
    page,
    totalPages: Math.ceil(total / limit)
  }
}
</code></pre>
<h3 id="caching-strategy">Caching Strategy</h3>
<pre><code class="language-typescript">@Injectable()
export class CacheService {
  private cache = new Map&lt;string, CacheEntry&gt;()

  async get&lt;T&gt;(key: string, factory: () =&gt; Promise&lt;T&gt;, ttl = 300000): Promise&lt;T&gt; {
    const cached = this.cache.get(key)
    
    if (cached &amp;&amp; cached.expiresAt &gt; Date.now()) {
      return cached.value as T
    }

    const value = await factory()
    this.cache.set(key, {
      value,
      expiresAt: Date.now() + ttl
    })

    return value
  }

  invalidate(pattern: string) {
    for (const key of this.cache.keys()) {
      if (key.includes(pattern)) {
        this.cache.delete(key)
      }
    }
  }
}
</code></pre>
<h2 id="team-collaboration">Team Collaboration</h2>
<h3 id="daily-standup-template">Daily Standup Template</h3>
<pre><code class="language-markdown">## Yesterday
- Completed user authentication feature
- Fixed bug in product search

## Today
- Working on favorites feature
- Code review for PR #123

## Blockers
- Need clarification on caching strategy
- Waiting for design approval
</code></pre>
<h3 id="documentation-standards">Documentation Standards</h3>
<pre><code class="language-typescript">/**
 * Finds a user by their email address
 * @param email - The email address to search for
 * @returns The user if found, null otherwise
 * @throws {ValidationException} If email format is invalid
 * @example
 * const user = await usersService.findByEmail(&#39;user@example.com&#39;)
 */
async findByEmail(email: string): Promise&lt;User | null&gt; {
  if (!isValidEmail(email)) {
    throw new ValidationException(&#39;Invalid email format&#39;)
  }
  
  return this.prisma.user.findUnique({
    where: { email: email.toLowerCase() }
  })
}
</code></pre>
<h3 id="knowledge-sharing">Knowledge Sharing</h3>
<ul>
<li><strong>Tech Talks</strong>: Weekly 30-minute sessions</li>
<li><strong>Pair Programming</strong>: For complex features</li>
<li><strong>Code Reviews</strong>: Learn from each other</li>
<li><strong>Documentation</strong>: Keep it updated</li>
<li><strong>Retrospectives</strong>: Continuous improvement</li>
</ul>
<h2 id="productivity-tips">Productivity Tips</h2>
<h3 id="keyboard-shortcuts">Keyboard Shortcuts</h3>
<pre><code># VS Code
Cmd/Ctrl + P         - Quick file open
Cmd/Ctrl + Shift + P - Command palette
Cmd/Ctrl + .         - Quick fix
F12                  - Go to definition
Shift + F12          - Find all references
</code></pre>
<h3 id="terminal-aliases">Terminal Aliases</h3>
<pre><code class="language-bash"># Add to ~/.zshrc or ~/.bashrc
alias dev=&quot;pnpm dev&quot;
alias test=&quot;pnpm test&quot;
alias build=&quot;pnpm build&quot;
alias gen=&quot;pnpm codegen&quot;
alias migrate=&quot;pnpm prisma:migrate:users &amp;&amp; pnpm prisma:migrate:products&quot;
</code></pre>
<h3 id="snippets">Snippets</h3>
<pre><code class="language-json">// VS Code snippets for GraphQL
{
  &quot;GraphQL Resolver&quot;: {
    &quot;prefix&quot;: &quot;resolver&quot;,
    &quot;body&quot;: [
      &quot;@Resolver(() =&gt; ${1:Entity})&quot;,
      &quot;export class ${1:Entity}Resolver {&quot;,
      &quot;  constructor(private readonly ${2:service}: ${1:Entity}Service) {}&quot;,
      &quot;&quot;,
      &quot;  @Query(() =&gt; [${1:Entity}])&quot;,
      &quot;  async ${3:findAll}(): Promise&lt;${1:Entity}[]&gt; {&quot;,
      &quot;    return this.${2:service}.${3:findAll}()&quot;,
      &quot;  }&quot;,
      &quot;}&quot;
    ]
  }
}
</code></pre>
<h2 id="continuous-learning">Continuous Learning</h2>
<ul>
<li><strong>Code Reviews</strong>: Learn from others</li>
<li><strong>Documentation</strong>: Read and contribute</li>
<li><strong>Experiments</strong>: Try new approaches</li>
<li><strong>Conferences</strong>: Stay updated</li>
<li><strong>Open Source</strong>: Contribute back</li>
</ul>
<p>Remember: Good development workflow is about consistency, communication, and continuous improvement.</p>
</div><div id="01-getting-started-03-troubleshooting" class="doc-section"><h1 id="troubleshooting-guide">Troubleshooting Guide</h1>
<p>This guide covers common issues and their solutions when working with the NestJS GraphQL Microservices project.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#service-startup-issues">Service Startup Issues</a></li>
<li><a href="#database-connection-problems">Database Connection Problems</a></li>
<li><a href="#graphql-errors">GraphQL Errors</a></li>
<li><a href="#code-generation-issues">Code Generation Issues</a></li>
<li><a href="#docker-issues">Docker Issues</a></li>
<li><a href="#federation-problems">Federation Problems</a></li>
<li><a href="#typescript-errors">TypeScript Errors</a></li>
<li><a href="#performance-issues">Performance Issues</a></li>
<li><a href="#development-environment">Development Environment</a></li>
</ul>
<h2 id="service-startup-issues">Service Startup Issues</h2>
<h3 id="port-already-in-use">Port Already in Use</h3>
<p><strong>Error:</strong></p>
<pre><code>Error: listen EADDRINUSE: address already in use :::3001
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li>Find and kill the process:</li>
</ol>
<pre><code class="language-bash"># Find process using the port
lsof -ti:3001

# Kill the process
kill -9 &lt;PID&gt;

# Or kill all services at once
lsof -ti:3000,3001,3002 | xargs kill -9
</code></pre>
<ol start="2">
<li>Use different ports:</li>
</ol>
<pre><code class="language-bash"># In .env file
PORT=3003
</code></pre>
<h3 id="service-failed-to-start">Service Failed to Start</h3>
<p><strong>Error:</strong></p>
<pre><code>Cannot find module &#39;@app/common/exceptions&#39;
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li>Check TypeScript paths in <code>tsconfig.base.json</code>:</li>
</ol>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;paths&quot;: {
      &quot;@app/common/*&quot;: [&quot;libs/common/*/src/index.ts&quot;]
    }
  }
}
</code></pre>
<ol start="2">
<li>Rebuild the project:</li>
</ol>
<pre><code class="language-bash">nx reset
pnpm install
nx build &lt;service-name&gt;
</code></pre>
<h3 id="gateway-cant-connect-to-services">Gateway Can&#39;t Connect to Services</h3>
<p><strong>Error:</strong></p>
<pre><code>Couldn&#39;t load service definitions for &quot;users&quot; at http://localhost:3001/graphql
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li>Ensure services start before gateway:</li>
</ol>
<pre><code class="language-bash"># Start services first
pnpm start:users
pnpm start:products

# Wait, then start gateway
pnpm start:gateway
</code></pre>
<ol start="2">
<li>Or use the dev script with proper timing:</li>
</ol>
<pre><code class="language-bash">pnpm dev
</code></pre>
<h2 id="database-connection-problems">Database Connection Problems</h2>
<h3 id="postgresql-connection-refused">PostgreSQL Connection Refused</h3>
<p><strong>Error:</strong></p>
<pre><code>PrismaClientInitializationError: Can&#39;t reach database server at `localhost:5432`
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li>Check if Docker containers are running:</li>
</ol>
<pre><code class="language-bash">docker ps
# If not running:
pnpm docker:up
</code></pre>
<ol start="2">
<li>Verify connection string in <code>.env</code>:</li>
</ol>
<pre><code class="language-env">DATABASE_URL=&quot;postgresql://postgres:postgres@localhost:5432/users_db?schema=public&quot;
</code></pre>
<ol start="3">
<li>Check Docker logs:</li>
</ol>
<pre><code class="language-bash">docker logs nestjs-users-db
</code></pre>
<h3 id="migration-failures">Migration Failures</h3>
<p><strong>Error:</strong></p>
<pre><code>Error: P3009 migrate found failed migrations in the target database
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li>Reset the database:</li>
</ol>
<pre><code class="language-bash"># Drop and recreate database
docker exec -it nestjs-users-db psql -U postgres -c &quot;DROP DATABASE users_db;&quot;
docker exec -it nestjs-users-db psql -U postgres -c &quot;CREATE DATABASE users_db;&quot;

# Run migrations again
pnpm prisma:migrate:users
</code></pre>
<ol start="2">
<li>Force reset (development only):</li>
</ol>
<pre><code class="language-bash">pnpm prisma migrate reset --schema=apps/users-service/prisma/schema.prisma
</code></pre>
<h3 id="prisma-client-out-of-sync">Prisma Client Out of Sync</h3>
<p><strong>Error:</strong></p>
<pre><code>The table `public.User` does not exist in the current database
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li>Regenerate Prisma client:</li>
</ol>
<pre><code class="language-bash">pnpm prisma:generate:users
pnpm prisma:generate:products
</code></pre>
<ol start="2">
<li>Run pending migrations:</li>
</ol>
<pre><code class="language-bash">pnpm prisma:migrate:users
pnpm prisma:migrate:products
</code></pre>
<h2 id="graphql-errors">GraphQL Errors</h2>
<h3 id="schema-mismatch">Schema Mismatch</h3>
<p><strong>Error:</strong></p>
<pre><code>GraphQLError: Cannot query field &quot;X&quot; on type &quot;Y&quot;
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li>Regenerate types:</li>
</ol>
<pre><code class="language-bash"># Ensure all services are running
pnpm dev

# In another terminal
pnpm codegen
</code></pre>
<ol start="2">
<li>Restart TypeScript server in IDE:</li>
</ol>
<ul>
<li>VS Code: <code>Cmd/Ctrl + Shift + P</code> ‚Üí &quot;TypeScript: Restart TS Server&quot;</li>
</ul>
<h3 id="federation-entity-not-found">Federation Entity Not Found</h3>
<p><strong>Error:</strong></p>
<pre><code>Cannot return null for non-nullable field User.email
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li>Implement proper reference resolver:</li>
</ol>
<pre><code class="language-typescript">@ResolveReference()
async resolveReference(reference: { __typename: string; id: string }) {
  const user = await this.usersService.findOneById(reference.id)
  if (!user) {
    // Log but don&#39;t throw
    this.logger.warn(`User ${reference.id} not found`)
    return null
  }
  return user
}
</code></pre>
<ol start="2">
<li>Check entity keys match:</li>
</ol>
<pre><code class="language-typescript">// Must be consistent across services
@Directive(&#39;@key(fields: &quot;id&quot;)&#39;)
</code></pre>
<h2 id="code-generation-issues">Code Generation Issues</h2>
<h3 id="services-not-running">Services Not Running</h3>
<p><strong>Error:</strong></p>
<pre><code>Failed to load schema from http://localhost:3001/graphql
</code></pre>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Start services first
pnpm dev

# Then in another terminal
pnpm codegen
</code></pre>
<h3 id="missing-types">Missing Types</h3>
<p><strong>Error:</strong></p>
<pre><code>Cannot find name &#39;I_Service&#39;
Cannot find name &#39;IQuery__EntitiesArgs&#39;
</code></pre>
<p><strong>Solution:</strong><br>These types are imported from <code>@libs/codegen</code>. Check that:</p>
<ol>
<li>The import exists in generated files</li>
<li>Federation types are properly exported:</li>
</ol>
<pre><code class="language-typescript">// libs/codegen/src/federation-types.ts
export interface I_Service {
  sdl: string;
}
</code></pre>
<h3 id="outdated-generated-files">Outdated Generated Files</h3>
<p><strong>Symptoms:</strong></p>
<ul>
<li>TypeScript errors after schema changes</li>
<li>Auto-completion not working</li>
</ul>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash"># Delete generated files
find . -path &quot;*/generated/*&quot; -type f -name &quot;*.ts&quot; -delete

# Regenerate
pnpm codegen
</code></pre>
<h2 id="docker-issues">Docker Issues</h2>
<h3 id="container-wont-start">Container Won&#39;t Start</h3>
<p><strong>Error:</strong></p>
<pre><code>docker: Error response from daemon: Conflict. The container name &quot;/nestjs-users-db&quot; is already in use
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li>Remove existing containers:</li>
</ol>
<pre><code class="language-bash">pnpm docker:down
docker rm -f nestjs-users-db nestjs-products-db
pnpm docker:up
</code></pre>
<ol start="2">
<li>Full reset:</li>
</ol>
<pre><code class="language-bash">pnpm project:reset
pnpm project:init
</code></pre>
<h3 id="out-of-disk-space">Out of Disk Space</h3>
<p><strong>Error:</strong></p>
<pre><code>no space left on device
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li>Clean Docker system:</li>
</ol>
<pre><code class="language-bash"># Remove unused containers, images, volumes
docker system prune -a --volumes

# Check space
docker system df
</code></pre>
<h3 id="permission-denied">Permission Denied</h3>
<p><strong>Error:</strong></p>
<pre><code>docker: Got permission denied while trying to connect to the Docker daemon socket
</code></pre>
<p>**Solution (Linux/Mac):</p>
<pre><code class="language-bash"># Add user to docker group
sudo usermod -aG docker $USER

# Restart session or run
newgrp docker
</code></pre>
<h2 id="federation-problems">Federation Problems</h2>
<h3 id="type-extensions-not-working">Type Extensions Not Working</h3>
<p><strong>Symptom:</strong><br>Products not showing on User type</p>
<p><strong>Solutions:</strong></p>
<ol>
<li>Verify federation setup:</li>
</ol>
<pre><code class="language-typescript">// In products service
@Resolver(() =&gt; User)
export class UserResolver {
  @ResolveField(() =&gt; [Product])
  async products(@Parent() user: User) {
    return this.productsService.findByUserId(user.id)
  }
}
</code></pre>
<ol start="2">
<li>Check gateway configuration includes all services:</li>
</ol>
<pre><code class="language-typescript">subgraphs: [
  { name: &#39;users&#39;, url: &#39;http://localhost:3001/graphql&#39; },
  { name: &#39;products&#39;, url: &#39;http://localhost:3002/graphql&#39; },
]
</code></pre>
<h3 id="query-planning-errors">Query Planning Errors</h3>
<p><strong>Error:</strong></p>
<pre><code>Query planning failed: Cannot find field &quot;products&quot; on type &quot;User&quot;
</code></pre>
<p><strong>Solution:</strong><br>Ensure proper directives:</p>
<pre><code class="language-typescript">@ObjectType()
@Directive(&#39;@extends&#39;)
@Directive(&#39;@key(fields: &quot;id&quot;)&#39;)
export class User {
  @Field(() =&gt; ID)
  @Directive(&#39;@external&#39;)
  id: string

  @Field(() =&gt; [Product])
  products?: Product[]
}
</code></pre>
<h2 id="typescript-errors">TypeScript Errors</h2>
<h3 id="module-resolution-issues">Module Resolution Issues</h3>
<p><strong>Error:</strong></p>
<pre><code>TS2307: Cannot find module &#39;@app/validation&#39; or its corresponding type declarations
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li>Check path mapping in <code>tsconfig.base.json</code></li>
<li>Ensure index.ts exports properly:</li>
</ol>
<pre><code class="language-typescript">// libs/validation/src/index.ts
export * from &#39;./lib/validation&#39;
</code></pre>
<ol start="3">
<li>Restart IDE/TypeScript server</li>
</ol>
<h3 id="type-mismatch-errors">Type Mismatch Errors</h3>
<p><strong>Error:</strong></p>
<pre><code>Type &#39;PrismaUser&#39; is not assignable to type &#39;IUser&#39;
</code></pre>
<p><strong>Solution:</strong><br>Use transformation functions:</p>
<pre><code class="language-typescript">private toGraphQLUser(user: PrismaUser): IUser {
  return {
    ...user,
    __typename: &#39;User&#39; as const
  }
}
</code></pre>
<h2 id="performance-issues">Performance Issues</h2>
<h3 id="slow-queries-n1-problem">Slow Queries (N+1 Problem)</h3>
<p><strong>Symptom:</strong><br>Multiple database queries for related data</p>
<p><strong>Solution:</strong><br>Implement DataLoader:</p>
<pre><code class="language-typescript">@Injectable()
export class UserLoader {
  createLoader() {
    return new DataLoader(async (ids: string[]) =&gt; {
      const users = await this.prisma.user.findMany({
        where: { id: { in: ids } }
      })
      return ids.map(id =&gt; users.find(u =&gt; u.id === id))
    })
  }
}
</code></pre>
<h3 id="high-memory-usage">High Memory Usage</h3>
<p><strong>Solutions:</strong></p>
<ol>
<li>Limit query depth:</li>
</ol>
<pre><code class="language-typescript">GraphQLModule.forRoot({
  validationRules: [depthLimit(5)]
})
</code></pre>
<ol start="2">
<li>Add pagination:</li>
</ol>
<pre><code class="language-typescript">@Query(() =&gt; [User])
async users(
  @Args(&#39;limit&#39;, { type: () =&gt; Int, defaultValue: 20 }) limit: number,
  @Args(&#39;offset&#39;, { type: () =&gt; Int, defaultValue: 0 }) offset: number
) {
  return this.prisma.user.findMany({ take: limit, skip: offset })
}
</code></pre>
<h2 id="development-environment">Development Environment</h2>
<h3 id="nx-cache-issues">NX Cache Issues</h3>
<p><strong>Symptoms:</strong></p>
<ul>
<li>Outdated build outputs</li>
<li>Changes not reflected</li>
</ul>
<p><strong>Solution:</strong></p>
<pre><code class="language-bash">nx reset
</code></pre>
<h3 id="ide-not-recognizing-types">IDE Not Recognizing Types</h3>
<p><strong>VS Code Solutions:</strong></p>
<ol>
<li>Reload window: <code>Cmd/Ctrl + Shift + P</code> ‚Üí &quot;Developer: Reload Window&quot;</li>
<li>Clear TypeScript cache: <code>Cmd/Ctrl + Shift + P</code> ‚Üí &quot;TypeScript: Restart TS Server&quot;</li>
<li>Ensure correct TypeScript version:</li>
</ol>
<pre><code class="language-json">// .vscode/settings.json
{
  &quot;typescript.tsdk&quot;: &quot;node_modules/typescript/lib&quot;
}
</code></pre>
<h3 id="git-pre-commit-hooks-failing">Git Pre-commit Hooks Failing</h3>
<p><strong>Error:</strong></p>
<pre><code>husky - pre-commit hook exited with code 1
</code></pre>
<p><strong>Solutions:</strong></p>
<ol>
<li>Fix linting errors:</li>
</ol>
<pre><code class="language-bash">pnpm lint --fix
</code></pre>
<ol start="2">
<li>Skip hooks temporarily (not recommended):</li>
</ol>
<pre><code class="language-bash">git commit --no-verify
</code></pre>
<h2 id="quick-fixes-checklist">Quick Fixes Checklist</h2>
<p>When something isn&#39;t working, try these in order:</p>
<ol>
<li>‚úÖ <strong>Restart services</strong>: <code>Ctrl+C</code> and <code>pnpm dev</code></li>
<li>‚úÖ <strong>Regenerate types</strong>: <code>pnpm codegen</code></li>
<li>‚úÖ <strong>Clear caches</strong>: <code>nx reset</code></li>
<li>‚úÖ <strong>Reinstall dependencies</strong>: <code>rm -rf node_modules &amp;&amp; pnpm install</code></li>
<li>‚úÖ <strong>Restart Docker</strong>: <code>pnpm docker:down &amp;&amp; pnpm docker:up</code></li>
<li>‚úÖ <strong>Full reset</strong>: <code>pnpm project:reset &amp;&amp; pnpm project:init</code></li>
</ol>
<h2 id="getting-help">Getting Help</h2>
<p>If you&#39;re still stuck:</p>
<ol>
<li>Check the <a href="https://go.nx.dev/community">NX Discord</a></li>
<li>Search <a href="https://github.com/nestjs/nest/issues">NestJS GitHub Issues</a></li>
<li>Review <a href="https://www.apollographql.com/docs/federation/">Apollo Federation Docs</a></li>
<li>Ask on <a href="https://stackoverflow.com/questions/tagged/nestjs">Stack Overflow</a></li>
</ol>
<p>Remember to include:</p>
<ul>
<li>Error messages</li>
<li>Steps to reproduce</li>
<li>Environment details (OS, Node version, etc.)</li>
<li>Relevant code snippets</li>
</ul>
</div><div id="01-getting-started-04-documentation-guide" class="doc-section"><h1 id="documentation-guide">üìö Documentation Guide</h1>
<h2 id="generating-documentation">Generating Documentation</h2>
<p>To generate a single HTML page containing all documentation:</p>
<pre><code class="language-bash">pnpm docs:generate
</code></pre>
<p>This will create the file <code>docs/all-documentation.html</code> which contains:</p>
<ul>
<li>‚úÖ All 16 documentation documents</li>
<li>‚úÖ Interactive navigation with table of contents</li>
<li>‚úÖ Mermaid diagram support</li>
<li>‚úÖ Syntax highlighting for code</li>
<li>‚úÖ Responsive design</li>
<li>‚úÖ Search with Ctrl+F</li>
</ul>
<h2 id="viewing-documentation">Viewing Documentation</h2>
<h3 id="option-1-open-directly">Option 1: Open Directly</h3>
<pre><code class="language-bash"># macOS
open docs/all-documentation.html

# Linux
xdg-open docs/all-documentation.html

# Windows
start docs/all-documentation.html
</code></pre>
<h3 id="option-2-local-server">Option 2: Local Server</h3>
<pre><code class="language-bash"># With Python
cd docs &amp;&amp; python3 -m http.server 8000

# Then open http://localhost:8000/all-documentation.html

# Or with Node.js
npx serve docs
# Then navigate to all-documentation.html
</code></pre>
<h2 id="documentation-structure">Documentation Structure</h2>
<pre><code class="language-text">docs/
‚îú‚îÄ‚îÄ all-documentation.html     # üìÑ Generated complete documentation
‚îú‚îÄ‚îÄ index.html                 # Auto-redirect to all-documentation.html
‚îú‚îÄ‚îÄ README.md                  # Main index
‚îú‚îÄ‚îÄ 01-getting-started/        # Introduction and basics
‚îú‚îÄ‚îÄ 02-architecture/           # Technical architecture
‚îú‚îÄ‚îÄ 03-development/            # Development guides
‚îú‚îÄ‚îÄ 04-best-practices/         # Standards and best practices
‚îî‚îÄ‚îÄ 05-operations/             # Deployment and operations
</code></pre>
<h2 id="features">Features</h2>
<ul>
<li><strong>Navigation</strong>: Fixed sidebar with all documents</li>
<li><strong>Search</strong>: Use Ctrl+F to search</li>
<li><strong>Back to Top</strong>: Floating button to return to top</li>
<li><strong>Internal Links</strong>: Navigation between sections</li>
<li><strong>Code</strong>: Copy buttons and syntax highlighting</li>
<li><strong>Diagrams</strong>: Automatic rendering of Mermaid diagrams</li>
<li><strong>Print</strong>: Optimized for printing (Ctrl+P)</li>
</ul>
<h2 id="customization">Customization</h2>
<p>To modify the style or structure, edit:</p>
<ul>
<li><code>scripts/generate-docs-html.js</code></li>
</ul>
<h2 id="deployment">Deployment</h2>
<p>The generated HTML file can be:</p>
<ul>
<li>üìß Sent by email</li>
<li>üåê Hosted on any web server</li>
<li>üíæ Used offline</li>
<li>üñ®Ô∏è Printed to PDF via browser</li>
</ul>
<h2 id="updating-documentation">Updating Documentation</h2>
<p>After modifying documentation:</p>
<pre><code class="language-bash"># Regenerate HTML
pnpm docs:generate
</code></pre>
<p>The documentation is now ready to be viewed!</p>
</div><div id="02-architecture-01-graphql-federation-guide" class="doc-section"><h1 id="graphql-federation-guide">GraphQL Federation Guide</h1>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#federation-concepts">Federation Concepts</a><ul>
<li><a href="#core-principles">Core Principles</a></li>
<li><a href="#key-components">Key Components</a></li>
</ul>
</li>
<li><a href="#federation-directives">Federation Directives</a><ul>
<li><a href="#key">@key</a></li>
<li><a href="#extends">@extends</a></li>
<li><a href="#external">@external</a></li>
<li><a href="#requires">@requires</a></li>
<li><a href="#provides">@provides</a></li>
</ul>
</li>
<li><a href="#setting-up-federation">Setting Up Federation</a><ul>
<li><a href="#1-configure-subgraph-services">1. Configure Subgraph Services</a></li>
<li><a href="#2-define-entities">2. Define Entities</a></li>
<li><a href="#3-implement-reference-resolver">3. Implement Reference Resolver</a></li>
<li><a href="#4-extend-types-across-services">4. Extend Types Across Services</a></li>
<li><a href="#5-configure-the-gateway">5. Configure the Gateway</a></li>
</ul>
</li>
<li><a href="#advanced-federation-patterns">Advanced Federation Patterns</a><ul>
<li><a href="#entity-relationships">Entity Relationships</a></li>
<li><a href="#computed-fields">Computed Fields</a></li>
<li><a href="#federation-with-authentication">Federation with Authentication</a></li>
<li><a href="#custom-directives">Custom Directives</a></li>
</ul>
</li>
<li><a href="#query-planning">Query Planning</a></li>
<li><a href="#performance-optimization">Performance Optimization</a></li>
<li><a href="#error-handling-in-federation">Error Handling in Federation</a></li>
<li><a href="#testing-federation">Testing Federation</a></li>
<li><a href="#best-practices">Best Practices</a></li>
<li><a href="#common-issues-and-solutions">Common Issues and Solutions</a></li>
<li><a href="#next-steps">Next Steps</a></li>
</ul>
<h2 id="overview">Overview</h2>
<p>Apollo Federation is a powerful architecture for building a distributed GraphQL system. It allows you to divide your GraphQL API across multiple services while presenting a unified graph to clients.</p>
<h2 id="federation-concepts">Federation Concepts</h2>
<h3 id="core-principles">Core Principles</h3>
<ol>
<li><strong>Separation of Concerns</strong> - Each service owns its domain</li>
<li><strong>Unified Graph</strong> - Single endpoint for clients</li>
<li><strong>Declarative Composition</strong> - Services declare their capabilities</li>
<li><strong>Type Extensions</strong> - Services can extend types from other services</li>
</ol>
<h3 id="key-components">Key Components</h3>
<ul>
<li><strong>Subgraph Services</strong> - Individual GraphQL services (Users, Products)</li>
<li><strong>Gateway</strong> - Composes subgraphs into a unified API</li>
<li><strong>Entities</strong> - Types that can be referenced across services</li>
<li><strong>Federation Directives</strong> - Special directives for composition</li>
</ul>
<h2 id="federation-directives">Federation Directives</h2>
<h3 id="key">@key</h3>
<p>Defines the primary key for an entity:</p>
<pre><code class="language-typescript">@ObjectType()
@Directive(&#39;@key(fields: &quot;id&quot;)&#39;)
export class User {
  @Field(() =&gt; ID)
  id: string

  @Field()
  email: string

  @Field()
  name: string
}
</code></pre>
<h3 id="extends">@extends</h3>
<p>Extends a type defined in another service:</p>
<pre><code class="language-typescript">// In Products service
@ObjectType()
@Directive(&#39;@extends&#39;)
@Directive(&#39;@key(fields: &quot;id&quot;)&#39;)
export class User {
  @Field(() =&gt; ID)
  @Directive(&#39;@external&#39;)
  id: string

  // Add new field to User
  @Field(() =&gt; [Product])
  products?: Product[]
}
</code></pre>
<h3 id="external">@external</h3>
<p>Marks a field as owned by another service:</p>
<pre><code class="language-typescript">@Field(() =&gt; ID)
@Directive(&#39;@external&#39;)
id: string
</code></pre>
<h3 id="requires">@requires</h3>
<p>Specifies fields needed from other services:</p>
<pre><code class="language-typescript">@Field()
@Directive(&#39;@requires(fields: &quot;email&quot;)&#39;)
displayName(@Parent() user: User): string {
  return `${user.name} &lt;${user.email}&gt;`
}
</code></pre>
<h3 id="provides">@provides</h3>
<p>Specifies fields this service can provide:</p>
<pre><code class="language-typescript">@Field(() =&gt; User)
@Directive(&#39;@provides(fields: &quot;name email&quot;)&#39;)
user: User
</code></pre>
<h2 id="setting-up-federation">Setting Up Federation</h2>
<h3 id="1-configure-subgraph-services">1. Configure Subgraph Services</h3>
<p>Each service must be federation-enabled:</p>
<pre><code class="language-typescript">// users-service/app.module.ts
import { ApolloFederationDriver, ApolloFederationDriverConfig } from &#39;@nestjs/apollo&#39;

@Module({
  imports: [
    GraphQLModule.forRoot&lt;ApolloFederationDriverConfig&gt;({
      driver: ApolloFederationDriver,
      autoSchemaFile: {
        federation: 2,  // Use Federation v2
      },
      playground: true,
      buildSchemaOptions: {
        orphanedTypes: [],  // Include types not directly referenced
      },
    }),
  ],
})
export class AppModule {}
</code></pre>
<h3 id="2-define-entities">2. Define Entities</h3>
<p>Create entities that can be referenced across services:</p>
<pre><code class="language-typescript">// users-service/entities/user.entity.ts
import { ObjectType, Field, ID, Directive } from &#39;@nestjs/graphql&#39;

@ObjectType()
@Directive(&#39;@key(fields: &quot;id&quot;)&#39;)
export class User {
  @Field(() =&gt; ID)
  id: string

  @Field()
  email: string

  @Field()
  name: string

  @Field()
  createdAt: Date

  @Field()
  updatedAt: Date

  // Password is not exposed in GraphQL
  password: string
}
</code></pre>
<h3 id="3-implement-reference-resolver">3. Implement Reference Resolver</h3>
<p>Reference resolvers fetch entities by their keys:</p>
<pre><code class="language-typescript">// users-service/users.resolver.ts
@Resolver(() =&gt; User)
export class UsersResolver {
  constructor(private readonly usersService: UsersService) {}

  @ResolveReference()
  async resolveReference(reference: { __typename: string; id: string }): Promise&lt;User | null&gt; {
    return this.usersService.findOneById(reference.id)
  }

  @Query(() =&gt; [User], { name: &#39;users&#39; })
  async findAll(): Promise&lt;User[]&gt; {
    return this.usersService.findAll()
  }

  @Query(() =&gt; User, { nullable: true })
  async user(@Args(&#39;id&#39;) id: string): Promise&lt;User | null&gt; {
    return this.usersService.findOneById(id)
  }
}
</code></pre>
<h3 id="4-extend-types-across-services">4. Extend Types Across Services</h3>
<p>In Products service, extend the User type:</p>
<pre><code class="language-typescript">// products-service/resolvers/user.resolver.ts
@Resolver(() =&gt; User)
export class UserResolver {
  constructor(private readonly productsService: ProductsService) {}

  @ResolveField(() =&gt; [Product])
  async products(@Parent() user: User): Promise&lt;Product[]&gt; {
    // user only has { id } from the gateway
    return this.productsService.findByUserId(user.id)
  }
}

// products-service/entities/user.entity.ts
@ObjectType()
@Directive(&#39;@extends&#39;)
@Directive(&#39;@key(fields: &quot;id&quot;)&#39;)
export class User {
  @Field(() =&gt; ID)
  @Directive(&#39;@external&#39;)
  id: string

  @Field(() =&gt; [Product])
  products?: Product[]
}
</code></pre>
<h3 id="5-configure-the-gateway">5. Configure the Gateway</h3>
<p>The gateway composes all subgraphs:</p>
<pre><code class="language-typescript">// api-gateway/app.module.ts
import { ApolloGatewayDriver, ApolloGatewayDriverConfig } from &#39;@nestjs/apollo&#39;
import { IntrospectAndCompose } from &#39;@apollo/gateway&#39;

@Module({
  imports: [
    GraphQLModule.forRoot&lt;ApolloGatewayDriverConfig&gt;({
      driver: ApolloGatewayDriver,
      server: {
        playground: true,
        introspection: true,
      },
      gateway: {
        supergraphSdl: new IntrospectAndCompose({
          subgraphs: [
            { name: &#39;users&#39;, url: &#39;http://localhost:3001/graphql&#39; },
            { name: &#39;products&#39;, url: &#39;http://localhost:3002/graphql&#39; },
          ],
        }),
      },
    }),
  ],
})
export class AppModule {}
</code></pre>
<h2 id="advanced-federation-patterns">Advanced Federation Patterns</h2>
<h3 id="entity-relationships">Entity Relationships</h3>
<h4 id="one-to-many-relationship">One-to-Many Relationship</h4>
<pre><code class="language-typescript">// User has many Products
@Resolver(() =&gt; User)
export class UserResolver {
  @ResolveField(() =&gt; [Product])
  async products(
    @Parent() user: User,
    @Args(&#39;limit&#39;, { type: () =&gt; Int, nullable: true }) limit?: number
  ): Promise&lt;Product[]&gt; {
    return this.productsService.findByUserId(user.id, { limit })
  }
}
</code></pre>
<h4 id="many-to-many-relationship">Many-to-Many Relationship</h4>
<pre><code class="language-typescript">// Product can have multiple categories from another service
@Resolver(() =&gt; Product)
export class ProductResolver {
  @ResolveField(() =&gt; [Category])
  async categories(@Parent() product: Product): Promise&lt;Category[]&gt; {
    // Return references for the gateway to resolve
    return product.categoryIds.map(id =&gt; ({
      __typename: &#39;Category&#39;,
      id
    }))
  }
}
</code></pre>
<h3 id="computed-fields">Computed Fields</h3>
<p>Add fields that don&#39;t exist in the database:</p>
<pre><code class="language-typescript">@Resolver(() =&gt; Product)
export class ProductResolver {
  @ResolveField(() =&gt; Boolean)
  inStock(@Parent() product: Product): boolean {
    return product.stock &gt; 0
  }

  @ResolveField(() =&gt; String)
  availability(@Parent() product: Product): string {
    if (product.stock === 0) return &#39;OUT_OF_STOCK&#39;
    if (product.stock &lt; 10) return &#39;LOW_STOCK&#39;
    return &#39;IN_STOCK&#39;
  }
}
</code></pre>
<h3 id="federation-with-authentication">Federation with Authentication</h3>
<p>Pass context through the gateway:</p>
<pre><code class="language-typescript">// Gateway configuration
gateway: {
  supergraphSdl: new IntrospectAndCompose({
    subgraphs: [/* ... */],
  }),
  buildService({ url }) {
    return new RemoteGraphQLDataSource({
      url,
      willSendRequest({ request, context }) {
        // Forward headers to subgraphs
        request.http.headers.set(&#39;authorization&#39;, context.req.headers.authorization)
        request.http.headers.set(&#39;user-id&#39;, context.userId)
      },
    })
  },
}
</code></pre>
<h3 id="custom-directives">Custom Directives</h3>
<p>Create custom federation directives:</p>
<pre><code class="language-typescript">@Directive(&#39;@custom(reason: &quot;Special handling&quot;)&#39;)
@Field()
specialField: string
</code></pre>
<h2 id="query-planning">Query Planning</h2>
<p>The gateway creates an efficient query plan:</p>
<h3 id="example-query">Example Query</h3>
<pre><code class="language-graphql">query GetUserWithProducts {
  user(id: &quot;123&quot;) {
    id
    name
    email
    products {
      id
      name
      price
      stock
    }
  }
}
</code></pre>
<h3 id="query-plan">Query Plan</h3>
<ol>
<li><p><strong>Fetch from Users Service</strong>:</p>
<pre><code class="language-graphql">{ user(id: &quot;123&quot;) { id name email } }
</code></pre>
</li>
<li><p><strong>Fetch from Products Service</strong>:</p>
<pre><code class="language-graphql">{ _entities(representations: [{__typename: &quot;User&quot;, id: &quot;123&quot;}]) {
    ... on User { products { id name price stock } }
  }
}
</code></pre>
</li>
<li><p><strong>Merge Results</strong> into final response</p>
</li>
</ol>
<h2 id="performance-optimization">Performance Optimization</h2>
<h3 id="1-implement-dataloader">1. Implement DataLoader</h3>
<p>Prevent N+1 queries in subgraphs:</p>
<pre><code class="language-typescript">@Injectable()
export class ProductsByUserLoader {
  constructor(private productsService: ProductsService) {}

  createLoader() {
    return new DataLoader&lt;string, Product[]&gt;(async (userIds) =&gt; {
      const products = await this.productsService.findByUserIds(userIds)
      
      const productsByUser = new Map&lt;string, Product[]&gt;()
      products.forEach(product =&gt; {
        if (!productsByUser.has(product.userId)) {
          productsByUser.set(product.userId, [])
        }
        productsByUser.get(product.userId).push(product)
      })
      
      return userIds.map(id =&gt; productsByUser.get(id) || [])
    })
  }
}
</code></pre>
<h3 id="2-use-field-hints">2. Use Field Hints</h3>
<p>Provide hints for better query planning:</p>
<pre><code class="language-typescript">@Field(() =&gt; [Product])
@Directive(&#39;@requires(fields: &quot;id&quot;)&#39;)
@Directive(&#39;@provides(fields: &quot;product { id name price }&quot;)&#39;)
products: Product[]
</code></pre>
<h3 id="3-implement-caching">3. Implement Caching</h3>
<p>Cache at the gateway level:</p>
<pre><code class="language-typescript">import { ApolloServerPluginCacheControl } from &#39;@apollo/server/plugin/cacheControl&#39;

plugins: [
  ApolloServerPluginCacheControl({
    defaultMaxAge: 5,
    calculateHttpHeaders: true,
  }),
]
</code></pre>
<h2 id="error-handling-in-federation">Error Handling in Federation</h2>
<h3 id="subgraph-errors">Subgraph Errors</h3>
<p>Handle errors gracefully in subgraphs:</p>
<pre><code class="language-typescript">@ResolveReference()
async resolveReference(reference: { id: string }): Promise&lt;User | null&gt; {
  try {
    return await this.usersService.findOneById(reference.id)
  } catch (error) {
    // Log but don&#39;t throw - return null for missing entities
    this.logger.warn(`User ${reference.id} not found`)
    return null
  }
}
</code></pre>
<h3 id="gateway-error-handling">Gateway Error Handling</h3>
<p>Configure error handling at the gateway:</p>
<pre><code class="language-typescript">gateway: {
  serviceHealthCheck: true,
  debug: process.env.NODE_ENV !== &#39;production&#39;,
  experimental_pollInterval: 10000,  // Re-poll services every 10s
}
</code></pre>
<h2 id="testing-federation">Testing Federation</h2>
<h3 id="unit-testing-resolvers">Unit Testing Resolvers</h3>
<pre><code class="language-typescript">describe(&#39;UserResolver (Federation)&#39;, () =&gt; {
  it(&#39;should resolve reference&#39;, async () =&gt; {
    const mockUser = { id: &#39;123&#39;, name: &#39;Test&#39; }
    mockUsersService.findOneById.mockResolvedValue(mockUser)

    const result = await resolver.resolveReference({ 
      __typename: &#39;User&#39;, 
      id: &#39;123&#39; 
    })

    expect(result).toEqual(mockUser)
  })
})
</code></pre>
<h3 id="integration-testing">Integration Testing</h3>
<p>Test the complete federated graph:</p>
<pre><code class="language-typescript">describe(&#39;Federated Graph&#39;, () =&gt; {
  it(&#39;should resolve cross-service query&#39;, async () =&gt; {
    const query = `
      query {
        user(id: &quot;123&quot;) {
          name
          products {
            name
            price
          }
        }
      }
    `

    const response = await request(gateway)
      .post(&#39;/graphql&#39;)
      .send({ query })

    expect(response.body.data.user).toBeDefined()
    expect(response.body.data.user.products).toBeArray()
  })
})
</code></pre>
<h2 id="best-practices">Best Practices</h2>
<ol>
<li><strong>Keep Entities Thin</strong> - Only include essential fields in entities</li>
<li><strong>Use Reference Resolvers</strong> - Always implement <code>@ResolveReference</code></li>
<li><strong>Avoid Circular Dependencies</strong> - Plan your type extensions carefully</li>
<li><strong>Monitor Performance</strong> - Use Apollo Studio for insights</li>
<li><strong>Version Carefully</strong> - Coordinate schema changes across services</li>
<li><strong>Document Ownership</strong> - Clear ownership of types and fields</li>
<li><strong>Test Federation</strong> - Test cross-service queries thoroughly</li>
</ol>
<h2 id="common-issues-and-solutions">Common Issues and Solutions</h2>
<h3 id="issue-entity-not-found">Issue: Entity Not Found</h3>
<pre><code class="language-typescript">// Problem: Gateway can&#39;t resolve entity
@ResolveReference()
async resolveReference(ref: { id: string }) {
  // Always handle missing entities gracefully
  const user = await this.usersService.findOneById(ref.id)
  if (!user) {
    this.logger.warn(`User ${ref.id} not found for federation`)
  }
  return user
}
</code></pre>
<h3 id="issue-field-conflicts">Issue: Field Conflicts</h3>
<pre><code class="language-typescript">// Ensure consistent field types across services
@Field(() =&gt; DateTime)  // Same type in all services
createdAt: Date
</code></pre>
<h3 id="issue-performance-degradation">Issue: Performance Degradation</h3>
<pre><code class="language-typescript">// Use DataLoader for batch loading
@ResolveField()
async user(@Parent() product: Product, @Context() context) {
  return context.userLoader.load(product.userId)
}
</code></pre>
<h2 id="next-steps">Next Steps</h2>
<ul>
<li>Read <a href="#adding-new-service">Adding a New Service</a> for federation setup</li>
<li>See <a href="#graphql-best-practices">GraphQL Best Practices</a> for resolver patterns</li>
<li>Check <a href="#codegen-guide">Code Generation Guide</a> for federation types</li>
<li>Review <a href="#nx-monorepo-guide">NX Monorepo Guide</a> for project structure</li>
</ul>
</div><div id="02-architecture-02-nx-monorepo-guide" class="doc-section"><h1 id="nx-monorepo-guide">NX Monorepo Guide</h1>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#core-concepts">Core Concepts</a><ul>
<li><a href="#workspace-structure">Workspace Structure</a></li>
<li><a href="#mental-model">Mental Model</a></li>
</ul>
</li>
<li><a href="#essential-nx-commands">Essential NX Commands</a><ul>
<li><a href="#development">Development</a></li>
<li><a href="#building">Building</a></li>
<li><a href="#testing">Testing</a></li>
<li><a href="#linting">Linting</a></li>
</ul>
</li>
<li><a href="#dependency-graph">Dependency Graph</a><ul>
<li><a href="#visualize-dependencies">Visualize Dependencies</a></li>
<li><a href="#understanding-dependencies">Understanding Dependencies</a></li>
</ul>
</li>
<li><a href="#affected-commands">Affected Commands</a></li>
<li><a href="#computation-caching">Computation Caching</a><ul>
<li><a href="#local-caching">Local Caching</a></li>
<li><a href="#cache-configuration">Cache Configuration</a></li>
<li><a href="#distributed-caching-with-nx-cloud">Distributed Caching with Nx Cloud</a></li>
</ul>
</li>
<li><a href="#task-orchestration">Task Orchestration</a><ul>
<li><a href="#run-tasks-in-parallel">Run Tasks in Parallel</a></li>
<li><a href="#custom-task-pipelines">Custom Task Pipelines</a></li>
</ul>
</li>
<li><a href="#generators">Generators</a><ul>
<li><a href="#using-built-in-generators">Using Built-in Generators</a></li>
<li><a href="#custom-generators">Custom Generators</a></li>
</ul>
</li>
<li><a href="#module-boundaries">Module Boundaries</a><ul>
<li><a href="#enforce-constraints">Enforce Constraints</a></li>
<li><a href="#tag-projects">Tag Projects</a></li>
</ul>
</li>
<li><a href="#performance-optimization">Performance Optimization</a><ul>
<li><a href="#1-use-computation-caching">1. Use Computation Caching</a></li>
<li><a href="#2-incremental-builds">2. Incremental Builds</a></li>
<li><a href="#3-parallel-execution">3. Parallel Execution</a></li>
<li><a href="#4-affected-only-in-ci">4. Affected Only in CI</a></li>
</ul>
</li>
<li><a href="#common-patterns">Common Patterns</a><ul>
<li><a href="#shared-configuration">Shared Configuration</a></li>
<li><a href="#environment-specific-builds">Environment-Specific Builds</a></li>
<li><a href="#workspace-libraries-pattern">Workspace Libraries Pattern</a></li>
</ul>
</li>
<li><a href="#troubleshooting">Troubleshooting</a><ul>
<li><a href="#clear-cache-issues">Clear Cache Issues</a></li>
<li><a href="#circular-dependencies">Circular Dependencies</a></li>
<li><a href="#out-of-memory">Out of Memory</a></li>
<li><a href="#module-resolution">Module Resolution</a></li>
</ul>
</li>
<li><a href="#cicd-integration">CI/CD Integration</a><ul>
<li><a href="#github-actions-example">GitHub Actions Example</a></li>
<li><a href="#optimize-ci-times">Optimize CI Times</a></li>
</ul>
</li>
<li><a href="#best-practices">Best Practices</a></li>
<li><a href="#next-steps">Next Steps</a></li>
</ul>
<h2 id="overview">Overview</h2>
<p>NX is a powerful build system that provides tools and techniques for managing monorepos at scale. This guide covers NX concepts, commands, and best practices specific to this GraphQL microservices project.</p>
<h2 id="core-concepts">Core Concepts</h2>
<h3 id="workspace-structure">Workspace Structure</h3>
<pre><code>.
‚îú‚îÄ‚îÄ apps/                      # Applications
‚îÇ   ‚îú‚îÄ‚îÄ api-gateway/          # Apollo Federation Gateway
‚îÇ   ‚îú‚îÄ‚îÄ users-service/        # Microservice
‚îÇ   ‚îî‚îÄ‚îÄ products-service/     # Microservice
‚îú‚îÄ‚îÄ libs/                      # Shared libraries
‚îÇ   ‚îú‚îÄ‚îÄ common/               # Common utilities
‚îÇ   ‚îî‚îÄ‚îÄ codegen/              # Code generation
‚îú‚îÄ‚îÄ tools/                     # Custom workspace tools
‚îú‚îÄ‚îÄ nx.json                    # NX configuration
‚îú‚îÄ‚îÄ workspace.json             # Workspace configuration
‚îî‚îÄ‚îÄ tsconfig.base.json        # Base TypeScript config
</code></pre>
<h3 id="mental-model">Mental Model</h3>
<ul>
<li><strong>Apps</strong>: Deployable units (services, gateways)</li>
<li><strong>Libs</strong>: Shared code (utilities, types, components)</li>
<li><strong>Tools</strong>: Build scripts and generators</li>
</ul>
<h2 id="essential-nx-commands">Essential NX Commands</h2>
<h3 id="development">Development</h3>
<pre><code class="language-bash"># Serve application
nx serve users-service

# Serve with production configuration
nx serve users-service --configuration=production

# Serve multiple apps
nx run-many --target=serve --projects=users-service,products-service
</code></pre>
<h3 id="building">Building</h3>
<pre><code class="language-bash"># Build single app
nx build api-gateway

# Build all apps
nx run-many --target=build --all

# Build only affected by changes
nx affected:build

# Build with specific configuration
nx build users-service --configuration=production
</code></pre>
<h3 id="testing">Testing</h3>
<pre><code class="language-bash"># Test single project
nx test users-service

# Test all projects
nx run-many --target=test --all

# Test only affected
nx affected:test

# Test with coverage
nx test users-service --coverage

# Test in watch mode
nx test users-service --watch
</code></pre>
<h3 id="linting">Linting</h3>
<pre><code class="language-bash"># Lint single project
nx lint products-service

# Lint all
nx run-many --target=lint --all

# Lint and fix
nx lint users-service --fix

# Lint only affected
nx affected:lint
</code></pre>
<h2 id="dependency-graph">Dependency Graph</h2>
<h3 id="visualize-dependencies">Visualize Dependencies</h3>
<pre><code class="language-bash"># Open interactive dependency graph
nx graph

# Generate dependency graph for affected projects
nx affected:graph

# Show dependencies of specific project
nx graph --focus=users-service
</code></pre>
<h3 id="understanding-dependencies">Understanding Dependencies</h3>
<p>NX automatically detects dependencies between projects:</p>
<pre><code class="language-typescript">// In users-service
import { isValidEmail } from &#39;@app/validation&#39; // Creates dependency on validation lib
</code></pre>
<h2 id="affected-commands">Affected Commands</h2>
<p>NX can determine which projects are affected by changes:</p>
<pre><code class="language-bash"># Show affected projects
nx affected:apps
nx affected:libs

# Run commands only on affected projects
nx affected:build
nx affected:test
nx affected:lint

# Compare against specific base
nx affected:test --base=main --head=HEAD
</code></pre>
<h2 id="computation-caching">Computation Caching</h2>
<h3 id="local-caching">Local Caching</h3>
<p>NX caches build outputs locally:</p>
<pre><code class="language-bash"># First run - executes
nx build users-service

# Second run - retrieves from cache (instant)
nx build users-service

# Clear cache
nx reset
</code></pre>
<h3 id="cache-configuration">Cache Configuration</h3>
<p>In <code>nx.json</code>:</p>
<pre><code class="language-json">{
  &quot;tasksRunnerOptions&quot;: {
    &quot;default&quot;: {
      &quot;runner&quot;: &quot;@nx/workspace/tasks-runners/default&quot;,
      &quot;options&quot;: {
        &quot;cacheableOperations&quot;: [&quot;build&quot;, &quot;lint&quot;, &quot;test&quot;],
        &quot;cacheDirectory&quot;: &quot;.nx/cache&quot;
      }
    }
  }
}
</code></pre>
<h3 id="distributed-caching-with-nx-cloud">Distributed Caching with Nx Cloud</h3>
<pre><code class="language-bash"># Connect to Nx Cloud
nx connect-to-nx-cloud

# Run with distributed cache
nx build users-service --skip-nx-cache=false
</code></pre>
<h2 id="task-orchestration">Task Orchestration</h2>
<h3 id="run-tasks-in-parallel">Run Tasks in Parallel</h3>
<pre><code class="language-json">// nx.json
{
  &quot;targetDefaults&quot;: {
    &quot;build&quot;: {
      &quot;dependsOn&quot;: [&quot;^build&quot;]  // Build dependencies first
    }
  }
}
</code></pre>
<h3 id="custom-task-pipelines">Custom Task Pipelines</h3>
<pre><code class="language-bash"># Run multiple targets in order
nx run-many --target=lint,test,build --all

# Run with specific parallelism
nx run-many --target=test --all --parallel=3
</code></pre>
<h2 id="generators">Generators</h2>
<h3 id="using-built-in-generators">Using Built-in Generators</h3>
<pre><code class="language-bash"># Generate new application
nx g @nx/nest:app new-service

# Generate library
nx g @nx/js:lib new-lib --directory=libs/common

# Generate with dry run
nx g @nx/nest:service user --project=users-service --dry-run
</code></pre>
<h3 id="custom-generators">Custom Generators</h3>
<p>Create custom generators in <code>tools/generators/</code>:</p>
<pre><code class="language-typescript">// tools/generators/service/index.ts
export default async function (tree: Tree, options: ServiceGeneratorSchema) {
  // Generate files
  generateFiles(tree, path.join(__dirname, &#39;files&#39;), options.projectRoot, options)
  
  // Update configuration
  updateProjectConfiguration(tree, options.name, {
    /* ... */
  })
  
  // Format files
  await formatFiles(tree)
}
</code></pre>
<p>Use custom generator:</p>
<pre><code class="language-bash">nx g @myorg/service:service my-feature
</code></pre>
<h2 id="module-boundaries">Module Boundaries</h2>
<h3 id="enforce-constraints">Enforce Constraints</h3>
<p>Configure in <code>.eslintrc.json</code>:</p>
<pre><code class="language-json">{
  &quot;overrides&quot;: [
    {
      &quot;rules&quot;: {
        &quot;@nx/enforce-module-boundaries&quot;: [
          &quot;error&quot;,
          {
            &quot;enforceBuildableLibDependency&quot;: true,
            &quot;allow&quot;: [],
            &quot;depConstraints&quot;: [
              {
                &quot;sourceTag&quot;: &quot;scope:users&quot;,
                &quot;onlyDependOnLibsWithTags&quot;: [&quot;scope:shared&quot;, &quot;scope:users&quot;]
              },
              {
                &quot;sourceTag&quot;: &quot;scope:products&quot;,
                &quot;onlyDependOnLibsWithTags&quot;: [&quot;scope:shared&quot;, &quot;scope:products&quot;]
              },
              {
                &quot;sourceTag&quot;: &quot;scope:shared&quot;,
                &quot;onlyDependOnLibsWithTags&quot;: [&quot;scope:shared&quot;]
              }
            ]
          }
        ]
      }
    }
  ]
}
</code></pre>
<h3 id="tag-projects">Tag Projects</h3>
<p>In <code>project.json</code>:</p>
<pre><code class="language-json">{
  &quot;tags&quot;: [&quot;scope:users&quot;, &quot;type:app&quot;],
  &quot;targets&quot;: {
    // ...
  }
}
</code></pre>
<h2 id="performance-optimization">Performance Optimization</h2>
<h3 id="1-use-computation-caching">1. Use Computation Caching</h3>
<pre><code class="language-bash"># Enable caching for custom targets
{
  &quot;targetDefaults&quot;: {
    &quot;docker-build&quot;: {
      &quot;cache&quot;: true,
      &quot;inputs&quot;: [&quot;default&quot;, &quot;{projectRoot}/Dockerfile&quot;],
      &quot;outputs&quot;: [&quot;{projectRoot}/dist&quot;]
    }
  }
}
</code></pre>
<h3 id="2-incremental-builds">2. Incremental Builds</h3>
<pre><code class="language-json">// tsconfig.json
{
  &quot;compilerOptions&quot;: {
    &quot;incremental&quot;: true,
    &quot;tsBuildInfoFile&quot;: &quot;.tsbuildinfo&quot;
  }
}
</code></pre>
<h3 id="3-parallel-execution">3. Parallel Execution</h3>
<pre><code class="language-bash"># Set max parallel processes
nx run-many --target=test --all --parallel=5

# Use all available CPUs
nx run-many --target=build --all --parallel
</code></pre>
<h3 id="4-affected-only-in-ci">4. Affected Only in CI</h3>
<pre><code class="language-yaml"># .github/workflows/ci.yml
- name: Test affected
  run: nx affected:test --base=${{ github.event.before }}
</code></pre>
<h2 id="common-patterns">Common Patterns</h2>
<h3 id="shared-configuration">Shared Configuration</h3>
<p>Create shared configs in libraries:</p>
<pre><code class="language-typescript">// libs/shared/config/src/lib/database.config.ts
export const databaseConfig = {
  type: &#39;postgres&#39;,
  synchronize: false,
  logging: process.env.NODE_ENV === &#39;development&#39;
}

// Use in apps
import { databaseConfig } from &#39;@app/shared/config&#39;
</code></pre>
<h3 id="environment-specific-builds">Environment-Specific Builds</h3>
<pre><code class="language-bash"># Development
nx serve users-service

# Production
nx serve users-service --configuration=production

# Custom environment
nx serve users-service --configuration=staging
</code></pre>
<p>Configure in <code>project.json</code>:</p>
<pre><code class="language-json">{
  &quot;configurations&quot;: {
    &quot;production&quot;: {
      &quot;optimization&quot;: true,
      &quot;extractLicenses&quot;: true,
      &quot;inspect&quot;: false
    },
    &quot;staging&quot;: {
      &quot;optimization&quot;: true,
      &quot;sourceMap&quot;: true
    }
  }
}
</code></pre>
<h3 id="workspace-libraries-pattern">Workspace Libraries Pattern</h3>
<pre><code>libs/
‚îú‚îÄ‚îÄ common/           # Shared across all apps
‚îÇ   ‚îú‚îÄ‚îÄ utils/       # Utility functions
‚îÇ   ‚îú‚îÄ‚îÄ exceptions/  # Custom exceptions
‚îÇ   ‚îî‚îÄ‚îÄ validation/  # Validation logic
‚îú‚îÄ‚îÄ backend/         # Backend-specific
‚îÇ   ‚îú‚îÄ‚îÄ prisma/     # Prisma utilities
‚îÇ   ‚îî‚îÄ‚îÄ auth/       # Auth utilities
‚îî‚îÄ‚îÄ frontend/        # Frontend-specific (if added)
    ‚îú‚îÄ‚îÄ ui/         # UI components
    ‚îî‚îÄ‚îÄ hooks/      # React hooks
</code></pre>
<h2 id="troubleshooting">Troubleshooting</h2>
<h3 id="clear-cache-issues">Clear Cache Issues</h3>
<pre><code class="language-bash"># Clear all caches
nx reset

# Clear specific cache
rm -rf .nx/cache

# Run without cache
nx build users-service --skip-nx-cache
</code></pre>
<h3 id="circular-dependencies">Circular Dependencies</h3>
<pre><code class="language-bash"># Find circular dependencies
nx graph

# Look for circular arrows in the graph
</code></pre>
<h3 id="out-of-memory">Out of Memory</h3>
<pre><code class="language-bash"># Increase Node memory
NODE_OPTIONS=&quot;--max-old-space-size=4096&quot; nx build all

# Reduce parallelism
nx run-many --target=build --all --parallel=2
</code></pre>
<h3 id="module-resolution">Module Resolution</h3>
<p>Ensure <code>tsconfig.base.json</code> has correct paths:</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;paths&quot;: {
      &quot;@app/validation&quot;: [&quot;libs/common/validation/src/index.ts&quot;],
      &quot;@app/*&quot;: [&quot;libs/*&quot;]
    }
  }
}
</code></pre>
<h2 id="cicd-integration">CI/CD Integration</h2>
<h3 id="github-actions-example">GitHub Actions Example</h3>
<pre><code class="language-yaml">name: CI
on: [push]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - uses: nrwl/nx-set-shas@v3
      
      - run: pnpm install
      
      - run: nx affected:lint
      - run: nx affected:test
      - run: nx affected:build
</code></pre>
<h3 id="optimize-ci-times">Optimize CI Times</h3>
<ol>
<li><strong>Use affected commands</strong></li>
<li><strong>Enable distributed caching</strong></li>
<li><strong>Parallelize jobs</strong></li>
<li><strong>Use remote caching</strong></li>
</ol>
<h2 id="best-practices">Best Practices</h2>
<ol>
<li><strong>Keep apps thin</strong> - Business logic in libraries</li>
<li><strong>Use tags</strong> - Enforce architectural boundaries</li>
<li><strong>Cache everything</strong> - Build, test, lint results</li>
<li><strong>Think in projects</strong> - Not files or folders</li>
<li><strong>Use affected</strong> - Don&#39;t rebuild everything</li>
<li><strong>Document deps</strong> - Make relationships explicit</li>
</ol>
<h2 id="next-steps">Next Steps</h2>
<ul>
<li>Read <a href="#adding-new-service">Adding a New Service</a> for service setup</li>
<li>See <a href="#adding-new-library">Adding a New Library</a> for library creation</li>
<li>Check <a href="#graphql-federation-guide">GraphQL Federation Guide</a> for distributed architecture</li>
</ul>
</div><div id="02-architecture-03-architecture-overview" class="doc-section"><h1 id="architecture-overview">Architecture Overview</h1>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#system-architecture">System Architecture</a></li>
<li><a href="#request-flow">Request Flow</a></li>
<li><a href="#federation-architecture">Federation Architecture</a></li>
<li><a href="#database-schema">Database Schema</a></li>
<li><a href="#deployment-architecture">Deployment Architecture</a></li>
<li><a href="#development-workflow">Development Workflow</a></li>
<li><a href="#cicd-pipeline">CI/CD Pipeline</a></li>
<li><a href="#service-communication-patterns">Service Communication Patterns</a></li>
<li><a href="#security-architecture">Security Architecture</a></li>
<li><a href="#monitoring-architecture">Monitoring Architecture</a></li>
<li><a href="#data-flow-architecture">Data Flow Architecture</a></li>
<li><a href="#scaling-strategy">Scaling Strategy</a></li>
<li><a href="#rendering-diagrams">Rendering Diagrams</a></li>
</ul>
<p>This document contains comprehensive architecture diagrams for the NestJS GraphQL Microservices project.</p>
<h2 id="system-architecture">System Architecture</h2>
<div class="mermaid">graph TB
    subgraph "Client Layer"
        Web[Web App]
        Mobile[Mobile App]
        API[API Clients]
    end
    
<pre><code>subgraph &quot;API Gateway Layer&quot;
    Gateway[Apollo Gateway&lt;br/&gt;:3000]
end

subgraph &quot;Microservices Layer&quot;
    Users[Users Service&lt;br/&gt;:3001]
    Products[Products Service&lt;br/&gt;:3002]
end

subgraph &quot;Data Layer&quot;
    UsersDB[(Users DB&lt;br/&gt;PostgreSQL&lt;br/&gt;:5432)]
    ProductsDB[(Products DB&lt;br/&gt;PostgreSQL&lt;br/&gt;:5433)]
end

Web --&gt; Gateway
Mobile --&gt; Gateway
API --&gt; Gateway

Gateway --&gt; Users
Gateway --&gt; Products

Users --&gt; UsersDB
Products --&gt; ProductsDB

Products -.-&gt;|Federation&lt;br/&gt;Reference| Users
</code></pre>
</div>

<h2 id="request-flow">Request Flow</h2>
<div class="mermaid">sequenceDiagram
    participant Client
    participant Gateway
    participant Users
    participant Products
    participant UsersDB
    participant ProductsDB
    
<pre><code>Client-&gt;&gt;Gateway: GraphQL Query
Gateway-&gt;&gt;Gateway: Query Planning

alt Simple User Query
    Gateway-&gt;&gt;Users: Get User Data
    Users-&gt;&gt;UsersDB: SQL Query
    UsersDB--&gt;&gt;Users: User Records
    Users--&gt;&gt;Gateway: User Response
else User with Products Query
    Gateway-&gt;&gt;Users: Get User Data
    Gateway-&gt;&gt;Products: Get Products by UserID
    Users-&gt;&gt;UsersDB: SQL Query
    Products-&gt;&gt;ProductsDB: SQL Query
    UsersDB--&gt;&gt;Users: User Records
    ProductsDB--&gt;&gt;Products: Product Records
    Users--&gt;&gt;Gateway: User Response
    Products--&gt;&gt;Gateway: Products Response
    Gateway-&gt;&gt;Gateway: Merge Results
end

Gateway--&gt;&gt;Client: Combined Response
</code></pre>
</div>

<h2 id="federation-architecture">Federation Architecture</h2>
<div class="mermaid">graph LR
    subgraph "API Gateway"
        Router[Query Router]
        Planner[Query Planner]
        Merger[Response Merger]
    end
    
<pre><code>subgraph &quot;Users Subgraph&quot;
    UserSchema[User Schema]
    UserResolver[User Resolver]
    UserEntity[User Entity&lt;br/&gt;@key: id]
end

subgraph &quot;Products Subgraph&quot;
    ProductSchema[Product Schema]
    ProductResolver[Product Resolver]
    UserExt[User Extension&lt;br/&gt;@extends User]
end

Router --&gt; Planner
Planner --&gt; UserResolver
Planner --&gt; ProductResolver

UserResolver --&gt; UserEntity
ProductResolver --&gt; UserExt

UserEntity -.-&gt;|Reference| UserExt

UserResolver --&gt; Merger
ProductResolver --&gt; Merger
</code></pre>
</div>

<h2 id="database-schema">Database Schema</h2>
<div class="mermaid">erDiagram
    User {
        string id PK
        string email UK
        string name
        string password
        datetime createdAt
        datetime updatedAt
    }
    
<pre><code>Product {
    string id PK
    string name
    string description
    decimal price
    string sku UK
    int stock
    string userId FK
    datetime createdAt
    datetime updatedAt
}

Favorite {
    string id PK
    string userId FK
    string productId FK
    datetime createdAt
}

User ||--o{ Product : owns
User ||--o{ Favorite : has
Product ||--o{ Favorite : is_favorited
</code></pre>
</div>

<h2 id="deployment-architecture">Deployment Architecture</h2>
<div class="mermaid">graph TB
    subgraph "Production Environment"
        subgraph "Load Balancer"
            LB[AWS ALB / Nginx]
        end
        
<pre><code>    subgraph &quot;Container Orchestration&quot;
        subgraph &quot;API Gateway Pods&quot;
            GW1[Gateway-1]
            GW2[Gateway-2]
            GW3[Gateway-3]
        end
        
        subgraph &quot;Users Service Pods&quot;
            US1[Users-1]
            US2[Users-2]
        end
        
        subgraph &quot;Products Service Pods&quot;
            PS1[Products-1]
            PS2[Products-2]
        end
    end
    
    subgraph &quot;Managed Services&quot;
        RDS1[(RDS Users)]
        RDS2[(RDS Products)]
        Redis[Redis Cache]
        S3[S3 Storage]
    end
end

LB --&gt; GW1
LB --&gt; GW2
LB --&gt; GW3

GW1 --&gt; US1
GW1 --&gt; US2
GW1 --&gt; PS1
GW1 --&gt; PS2

US1 --&gt; RDS1
US2 --&gt; RDS1
PS1 --&gt; RDS2
PS2 --&gt; RDS2

US1 --&gt; Redis
PS1 --&gt; Redis
</code></pre>
</div>

<h2 id="development-workflow">Development Workflow</h2>
<div class="mermaid">gitGraph
    commit id: "main"
    branch feature/user-auth
    checkout feature/user-auth
    commit id: "Add auth module"
    commit id: "Add JWT strategy"
    commit id: "Add tests"
    checkout main
    merge feature/user-auth
    
<pre><code>branch feature/products-api
checkout feature/products-api
commit id: &quot;Add products schema&quot;
commit id: &quot;Add products resolver&quot;
checkout main
merge feature/products-api

branch hotfix/security-patch
checkout hotfix/security-patch
commit id: &quot;Fix vulnerability&quot;
checkout main
merge hotfix/security-patch tag: &quot;v1.0.1&quot;
</code></pre>
</div>

<h2 id="cicd-pipeline">CI/CD Pipeline</h2>
<div class="mermaid">graph LR
    subgraph "Source Control"
        Git[GitHub/GitLab]
    end
    
<pre><code>subgraph &quot;CI Pipeline&quot;
    Test[Run Tests]
    Lint[Lint Code]
    Build[Build Images]
    Scan[Security Scan]
end

subgraph &quot;Registry&quot;
    ECR[Container Registry]
end

subgraph &quot;CD Pipeline&quot;
    Deploy[Deploy to K8s]
    Migrate[Run Migrations]
    Health[Health Checks]
end

subgraph &quot;Environments&quot;
    Dev[Development]
    Staging[Staging]
    Prod[Production]
end

Git --&gt; Test
Test --&gt; Lint
Lint --&gt; Build
Build --&gt; Scan
Scan --&gt; ECR
ECR --&gt; Deploy
Deploy --&gt; Migrate
Migrate --&gt; Health
Health --&gt; Dev
Dev --&gt; Staging
Staging --&gt; Prod
</code></pre>
</div>

<h2 id="service-communication-patterns">Service Communication Patterns</h2>
<div class="mermaid">graph TB
    subgraph "Synchronous Communication"
        subgraph "GraphQL Federation"
            GQL1[Service A] -->|GraphQL| GQL2[Service B]
        end
        
<pre><code>    subgraph &quot;REST (Internal)&quot;
        REST1[Service C] --&gt;|HTTP/REST| REST2[Service D]
    end
end

subgraph &quot;Asynchronous Communication&quot;
    subgraph &quot;Event Bus&quot;
        Publisher[Service E] --&gt;|Publish| EventBus[RabbitMQ/Kafka]
        EventBus --&gt;|Subscribe| Subscriber1[Service F]
        EventBus --&gt;|Subscribe| Subscriber2[Service G]
    end
end

subgraph &quot;Caching Layer&quot;
    Cache[Redis] --&gt; GQL1
    Cache --&gt; REST1
    Cache --&gt; Publisher
end
</code></pre>
</div>

<h2 id="security-architecture">Security Architecture</h2>
<div class="mermaid">graph TB
    subgraph "External"
        Client[Client Application]
    end
    
<pre><code>subgraph &quot;Edge Security&quot;
    WAF[Web Application Firewall]
    DDoS[DDoS Protection]
end

subgraph &quot;API Gateway Security&quot;
    RateLimit[Rate Limiting]
    Auth[Authentication]
    CORS[CORS Policy]
end

subgraph &quot;Service Security&quot;
    JWT[JWT Validation]
    RBAC[Role-Based Access]
    Encryption[Data Encryption]
end

subgraph &quot;Data Security&quot;
    DBEncrypt[DB Encryption at Rest]
    TLS[TLS in Transit]
    Backup[Encrypted Backups]
end

Client --&gt; WAF
WAF --&gt; DDoS
DDoS --&gt; RateLimit
RateLimit --&gt; Auth
Auth --&gt; CORS
CORS --&gt; JWT
JWT --&gt; RBAC
RBAC --&gt; Encryption
Encryption --&gt; DBEncrypt
DBEncrypt --&gt; TLS
TLS --&gt; Backup
</code></pre>
</div>

<h2 id="monitoring-architecture">Monitoring Architecture</h2>
<div class="mermaid">graph TB
    subgraph "Application Layer"
        App1[Gateway]
        App2[Users Service]
        App3[Products Service]
    end
    
<pre><code>subgraph &quot;Telemetry Collection&quot;
    Metrics[Prometheus]
    Logs[ELK Stack]
    Traces[Jaeger/Zipkin]
end

subgraph &quot;Visualization&quot;
    Grafana[Grafana Dashboards]
    Kibana[Kibana Logs]
    Jaeger[Jaeger UI]
end

subgraph &quot;Alerting&quot;
    Alert[Alert Manager]
    Slack[Slack]
    PagerDuty[PagerDuty]
end

App1 --&gt; Metrics
App1 --&gt; Logs
App1 --&gt; Traces

App2 --&gt; Metrics
App2 --&gt; Logs
App2 --&gt; Traces

App3 --&gt; Metrics
App3 --&gt; Logs
App3 --&gt; Traces

Metrics --&gt; Grafana
Logs --&gt; Kibana
Traces --&gt; Jaeger

Grafana --&gt; Alert
Alert --&gt; Slack
Alert --&gt; PagerDuty
</code></pre>
</div>

<h2 id="data-flow-architecture">Data Flow Architecture</h2>
<div class="mermaid">graph LR
    subgraph "Input Layer"
        GraphQL[GraphQL Query]
        REST[REST Request]
    end
    
<pre><code>subgraph &quot;Validation Layer&quot;
    InputVal[Input Validation]
    AuthCheck[Auth Check]
    RateCheck[Rate Limit Check]
end

subgraph &quot;Business Logic&quot;
    Resolver[Resolver/Controller]
    Service[Service Layer]
    DataLoader[DataLoader]
end

subgraph &quot;Data Access&quot;
    Prisma[Prisma ORM]
    Cache[Cache Layer]
end

subgraph &quot;Storage&quot;
    DB[(PostgreSQL)]
    Redis[(Redis)]
end

GraphQL --&gt; InputVal
REST --&gt; InputVal
InputVal --&gt; AuthCheck
AuthCheck --&gt; RateCheck
RateCheck --&gt; Resolver
Resolver --&gt; Service
Service --&gt; DataLoader
DataLoader --&gt; Cache
Cache --&gt; Prisma
Cache --&gt; Redis
Prisma --&gt; DB
</code></pre>
</div>

<h2 id="scaling-strategy">Scaling Strategy</h2>
<div class="mermaid">graph TB
    subgraph "Horizontal Scaling"
        subgraph "Auto Scaling Groups"
            ASG1[Gateway ASG<br/>Min: 2, Max: 10]
            ASG2[Users ASG<br/>Min: 2, Max: 5]
            ASG3[Products ASG<br/>Min: 2, Max: 5]
        end
    end
    
<pre><code>subgraph &quot;Vertical Scaling&quot;
    subgraph &quot;Database&quot;
        Master[(Primary DB&lt;br/&gt;Writable)]
        Replica1[(Read Replica 1)]
        Replica2[(Read Replica 2)]
    end
end

subgraph &quot;Caching Strategy&quot;
    CDN[CloudFront CDN]
    AppCache[Application Cache]
    DBCache[Query Cache]
end

ASG1 --&gt; Master
ASG1 --&gt; Replica1
ASG1 --&gt; Replica2

ASG2 --&gt; Master
ASG2 --&gt; Replica1

ASG3 --&gt; Master
ASG3 --&gt; Replica2

CDN --&gt; ASG1
ASG1 --&gt; AppCache
AppCache --&gt; DBCache
</code></pre>
</div>

<h2 id="rendering-diagrams">Rendering Diagrams</h2>
<p>These diagrams use Mermaid syntax and can be rendered in:</p>
<ul>
<li>GitHub/GitLab (automatic rendering)</li>
<li>VS Code with Mermaid plugin</li>
<li>Online at <a href="https://mermaid.live">mermaid.live</a></li>
<li>Documentation sites like Docusaurus</li>
</ul>
<p>To export as images:</p>
<ol>
<li>Copy the Mermaid code</li>
<li>Paste into <a href="https://mermaid.live">mermaid.live</a></li>
<li>Export as PNG/SVG</li>
<li>Save to this folder</li>
</ol>
</div><div id="03-development-01-adding-new-service" class="doc-section"><h1 id="adding-a-new-service-to-the-microservices-architecture">Adding a New Service to the Microservices Architecture</h1>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#step-by-step-guide">Step-by-Step Guide</a><ul>
<li><a href="#1-generate-the-service-structure">1. Generate the Service Structure</a></li>
<li><a href="#2-configure-database-in-docker">2. Configure Database in Docker</a></li>
<li><a href="#3-set-up-prisma">3. Set Up Prisma</a></li>
<li><a href="#4-configure-graphql-module">4. Configure GraphQL Module</a></li>
<li><a href="#5-create-feature-module">5. Create Feature Module</a></li>
<li><a href="#6-register-with-api-gateway">6. Register with API Gateway</a></li>
<li><a href="#7-configure-code-generation">7. Configure Code Generation</a></li>
<li><a href="#8-create-graphql-operations">8. Create GraphQL Operations</a></li>
<li><a href="#9-update-development-scripts">9. Update Development Scripts</a></li>
<li><a href="#10-federation-extending-types-optional">10. Federation - Extending Types (Optional)</a></li>
</ul>
</li>
<li><a href="#running-the-new-service">Running the New Service</a></li>
<li><a href="#checklist">Checklist</a></li>
<li><a href="#troubleshooting">Troubleshooting</a><ul>
<li><a href="#port-conflicts">Port Conflicts</a></li>
<li><a href="#typescript-errors">TypeScript Errors</a></li>
<li><a href="#database-connection">Database Connection</a></li>
<li><a href="#gateway-registration">Gateway Registration</a></li>
</ul>
</li>
</ul>
<p>This guide explains how to add a new microservice to the NestJS GraphQL Federation architecture.</p>
<h2 id="overview">Overview</h2>
<p>Each service in this architecture:</p>
<ul>
<li>Has its own PostgreSQL database</li>
<li>Exposes a GraphQL subgraph</li>
<li>Is registered with the Apollo Gateway</li>
<li>Uses Prisma as ORM</li>
<li>Has TypeScript types generated by GraphQL Code Generator</li>
</ul>
<h2 id="step-by-step-guide">Step-by-Step Guide</h2>
<h3 id="1-generate-the-service-structure">1. Generate the Service Structure</h3>
<p>Use Nx to scaffold a new NestJS application:</p>
<pre><code class="language-bash">nx g @nx/nest:app &lt;service-name&gt;
# Example: nx g @nx/nest:app orders-service
</code></pre>
<h3 id="2-configure-database-in-docker">2. Configure Database in Docker</h3>
<p>Add a new PostgreSQL container in <code>docker-compose.yml</code>:</p>
<pre><code class="language-yaml">postgres-&lt;service&gt;:
  image: postgres:16-alpine
  container_name: nestjs-&lt;service&gt;-db
  environment:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_DB: &lt;service&gt;_db
  ports:
    - &#39;543X:5432&#39;  # Use next available port (5434, 5435, etc.)
  volumes:
    - postgres-&lt;service&gt;-data:/var/lib/postgresql/data
</code></pre>
<p>Don&#39;t forget to add the volume:</p>
<pre><code class="language-yaml">volumes:
  postgres-&lt;service&gt;-data:
</code></pre>
<h3 id="3-set-up-prisma">3. Set Up Prisma</h3>
<h4 id="create-prisma-schema">Create Prisma Schema</h4>
<p>Create <code>apps/&lt;service-name&gt;/prisma/schema.prisma</code>:</p>
<pre><code class="language-prisma">generator client {
  provider = &quot;prisma-client-js&quot;
  output   = &quot;../../../node_modules/@prisma/client-&lt;service&gt;&quot;
}

datasource db {
  provider = &quot;postgresql&quot;
  url      = env(&quot;DATABASE_URL&quot;)
}

model YourModel {
  id        String   @id @default(uuid())
  // Add your fields here
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
</code></pre>
<h4 id="create-environment-file">Create Environment File</h4>
<p>Create <code>apps/&lt;service-name&gt;/.env</code>:</p>
<pre><code class="language-env">DATABASE_URL=&quot;postgresql://postgres:postgres@localhost:543X/&lt;service&gt;_db?schema=public&quot;
PORT=300X
</code></pre>
<h4 id="add-prisma-scripts">Add Prisma Scripts</h4>
<p>Add to <code>package.json</code>:</p>
<pre><code class="language-json">&quot;prisma:generate:&lt;service&gt;&quot;: &quot;dotenv -e apps/&lt;service-name&gt;/.env -- prisma generate --schema=apps/&lt;service-name&gt;/prisma/schema.prisma&quot;,
&quot;prisma:migrate:&lt;service&gt;&quot;: &quot;dotenv -e apps/&lt;service-name&gt;/.env -- prisma migrate dev --schema=apps/&lt;service-name&gt;/prisma/schema.prisma&quot;,
&quot;prisma:seed:&lt;service&gt;&quot;: &quot;cd apps/&lt;service-name&gt; &amp;&amp; dotenv -e .env -- ts-node --project tsconfig.seed.json prisma/seed.ts&quot;,
&quot;prisma:studio:&lt;service&gt;&quot;: &quot;dotenv -e apps/&lt;service-name&gt;/.env -- prisma studio --schema=apps/&lt;service-name&gt;/prisma/schema.prisma --port 555X&quot;,
&quot;start:&lt;service&gt;&quot;: &quot;nx serve &lt;service-name&gt;&quot;,
</code></pre>
<h3 id="4-configure-graphql-module">4. Configure GraphQL Module</h3>
<p>Update <code>apps/&lt;service-name&gt;/src/app/app.module.ts</code>:</p>
<pre><code class="language-typescript">import { Module } from &#39;@nestjs/common&#39;;
import { GraphQLModule } from &#39;@nestjs/graphql&#39;;
import { ApolloFederationDriver, ApolloFederationDriverConfig } from &#39;@nestjs/apollo&#39;;

@Module({
  imports: [
    GraphQLModule.forRoot&lt;ApolloFederationDriverConfig&gt;({
      driver: ApolloFederationDriver,
      autoSchemaFile: {
        federation: 2,
      },
      playground: true,
    }),
    // Add your feature modules here
  ],
})
export class AppModule {}
</code></pre>
<h3 id="5-create-feature-module">5. Create Feature Module</h3>
<p>Create your feature module structure:</p>
<pre><code>apps/&lt;service-name&gt;/src/app/&lt;feature&gt;/
‚îú‚îÄ‚îÄ &lt;feature&gt;.module.ts
‚îú‚îÄ‚îÄ &lt;feature&gt;.resolver.ts
‚îú‚îÄ‚îÄ &lt;feature&gt;.service.ts
‚îú‚îÄ‚îÄ dto/
‚îÇ   ‚îú‚îÄ‚îÄ create-&lt;entity&gt;.input.ts
‚îÇ   ‚îî‚îÄ‚îÄ update-&lt;entity&gt;.input.ts
‚îî‚îÄ‚îÄ entities/
    ‚îî‚îÄ‚îÄ &lt;entity&gt;.entity.ts
</code></pre>
<h3 id="6-register-with-api-gateway">6. Register with API Gateway</h3>
<p>Update <code>apps/api-gateway/src/app/app.module.ts</code>:</p>
<pre><code class="language-typescript">GraphQLModule.forRoot&lt;ApolloGatewayDriverConfig&gt;({
  driver: ApolloGatewayDriver,
  server: {
    playground: true,
  },
  gateway: {
    supergraphSdl: new IntrospectAndCompose({
      subgraphs: [
        { name: &#39;users&#39;, url: &#39;http://localhost:3001/graphql&#39; },
        { name: &#39;products&#39;, url: &#39;http://localhost:3002/graphql&#39; },
        { name: &#39;&lt;service&gt;&#39;, url: &#39;http://localhost:300X/graphql&#39; }, // Add your service
      ],
    }),
  },
}),
</code></pre>
<h3 id="7-configure-code-generation">7. Configure Code Generation</h3>
<p>Add to <code>codegen.yml</code>:</p>
<pre><code class="language-yaml"># &lt;Service&gt; service schema extraction
apps/&lt;service-name&gt;/src/generated/&lt;service&gt;-schema.graphql:
  schema:
    - http://localhost:300X/graphql
  plugins:
    - schema-ast
  config:
    includeDirectives: true
    federation: true
    
# &lt;Service&gt; service types
apps/&lt;service-name&gt;/src/generated/graphql.ts:
  schema:
    - http://localhost:300X/graphql
  plugins:
    - add:
        content: |
          /* eslint-disable */
          import type { I_Service, IQuery__EntitiesArgs } from &#39;@libs/codegen&#39;;
    - typescript
    - typescript-resolvers
  config:
    enumsAsTypes: true
    nonOptionalTypename: true
    scalars:
      DateTime: string
    federation: true
    avoidOptionals: true
    mappers:
      YourModel: &quot;@prisma/client-&lt;service&gt;#YourModel as YourModelModel&quot;
    contextType: &quot;@libs/codegen#IGraphQLContext&quot;
    typesPrefix: &#39;I&#39;
    typesSuffix: &#39;&#39;
    skipTypename: false
    useTypeImports: true
</code></pre>
<h3 id="8-create-graphql-operations">8. Create GraphQL Operations</h3>
<p>Create <code>libs/codegen/src/operations/&lt;service&gt;.graphql</code>:</p>
<pre><code class="language-graphql">query GetAll&lt;Entities&gt; {
  &lt;entities&gt; {
    id
    # Add fields
    createdAt
    updatedAt
  }
}

query Get&lt;Entity&gt;ById($id: String!) {
  &lt;entity&gt;(id: $id) {
    id
    # Add fields
    createdAt
    updatedAt
  }
}

mutation Create&lt;Entity&gt;($create&lt;Entity&gt;Input: Create&lt;Entity&gt;Input!) {
  create&lt;Entity&gt;(create&lt;Entity&gt;Input: $create&lt;Entity&gt;Input) {
    id
    # Add fields
  }
}

mutation Update&lt;Entity&gt;($update&lt;Entity&gt;Input: Update&lt;Entity&gt;Input!) {
  update&lt;Entity&gt;(update&lt;Entity&gt;Input: $update&lt;Entity&gt;Input) {
    id
    # Add fields
  }
}

mutation Remove&lt;Entity&gt;($id: String!) {
  remove&lt;Entity&gt;(id: $id) {
    id
  }
}
</code></pre>
<h3 id="9-update-development-scripts">9. Update Development Scripts</h3>
<p>Update the <code>dev</code> script in <code>package.json</code>:</p>
<pre><code class="language-json">&quot;dev&quot;: &quot;concurrently \&quot;pnpm start:users\&quot; \&quot;pnpm start:products\&quot; \&quot;pnpm start:&lt;service&gt;\&quot; \&quot;sleep 10 &amp;&amp; pnpm start:gateway\&quot;&quot;
</code></pre>
<h3 id="10-federation-extending-types-optional">10. Federation - Extending Types (Optional)</h3>
<p>If your service needs to extend types from other services:</p>
<pre><code class="language-typescript">// In your entity
@Directive(&#39;@key(fields: &quot;id&quot;)&#39;)
@ObjectType()
export class YourEntity {
  @Field(() =&gt; ID)
  id: string;

  @Field()
  userId: string;

  // Extend User type
  @Field(() =&gt; User)
  user?: User;
}

// In your resolver
@ResolveField(() =&gt; User)
async user(@Parent() entity: YourEntity) {
  return { __typename: &#39;User&#39;, id: entity.userId };
}
</code></pre>
<h2 id="running-the-new-service">Running the New Service</h2>
<ol>
<li>Start Docker containers: <code>pnpm docker:up</code></li>
<li>Generate Prisma client: <code>pnpm prisma:generate:&lt;service&gt;</code></li>
<li>Run migrations: <code>pnpm prisma:migrate:&lt;service&gt;</code></li>
<li>Seed database (optional): <code>pnpm prisma:seed:&lt;service&gt;</code></li>
<li>Start all services: <code>pnpm dev</code></li>
<li>Generate GraphQL types: <code>pnpm codegen</code></li>
</ol>
<h2 id="checklist">Checklist</h2>
<ul>
<li><input disabled="" type="checkbox"> Service generated with Nx</li>
<li><input disabled="" type="checkbox"> PostgreSQL container configured</li>
<li><input disabled="" type="checkbox"> Prisma schema created</li>
<li><input disabled="" type="checkbox"> Environment variables set</li>
<li><input disabled="" type="checkbox"> Package.json scripts added</li>
<li><input disabled="" type="checkbox"> GraphQL module configured</li>
<li><input disabled="" type="checkbox"> Feature module implemented</li>
<li><input disabled="" type="checkbox"> Service registered in gateway</li>
<li><input disabled="" type="checkbox"> Codegen configuration added</li>
<li><input disabled="" type="checkbox"> GraphQL operations created</li>
<li><input disabled="" type="checkbox"> Dev script updated</li>
<li><input disabled="" type="checkbox"> Service starts successfully</li>
<li><input disabled="" type="checkbox"> GraphQL types generated</li>
</ul>
<h2 id="troubleshooting">Troubleshooting</h2>
<h3 id="port-conflicts">Port Conflicts</h3>
<ul>
<li>Ensure each service uses a unique port (3001, 3002, 3003, etc.)</li>
<li>Database ports should also be unique (5432, 5433, 5434, etc.)</li>
</ul>
<h3 id="typescript-errors">TypeScript Errors</h3>
<ul>
<li>Run <code>pnpm codegen</code> after starting all services</li>
<li>Check that federation types are imported correctly</li>
</ul>
<h3 id="database-connection">Database Connection</h3>
<ul>
<li>Verify DATABASE_URL in .env file</li>
<li>Ensure Docker container is running</li>
<li>Check port mapping in docker-compose.yml</li>
</ul>
<h3 id="gateway-registration">Gateway Registration</h3>
<ul>
<li>Service must be running before gateway starts</li>
<li>Check the service URL in gateway configuration</li>
<li>Verify the subgraph name matches across configurations</li>
</ul>
</div><div id="03-development-02-adding-new-library" class="doc-section"><h1 id="adding-a-new-library">Adding a New Library</h1>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#types-of-libraries">Types of Libraries</a><ul>
<li><a href="#1-feature-libraries">1. Feature Libraries</a></li>
<li><a href="#2-data-access-libraries">2. Data Access Libraries</a></li>
<li><a href="#3-utility-libraries">3. Utility Libraries</a></li>
<li><a href="#4-ui-libraries">4. UI Libraries</a></li>
</ul>
</li>
<li><a href="#creating-a-new-library">Creating a New Library</a><ul>
<li><a href="#basic-library-generation">Basic Library Generation</a></li>
<li><a href="#library-structure">Library Structure</a></li>
</ul>
</li>
<li><a href="#step-by-step-creating-a-validation-library">Step-by-Step: Creating a Validation Library</a><ul>
<li><a href="#1-generate-the-library">1. Generate the Library</a></li>
<li><a href="#2-configure-typescript-path">2. Configure TypeScript Path</a></li>
<li><a href="#3-implement-library-code">3. Implement Library Code</a></li>
<li><a href="#4-export-public-api">4. Export Public API</a></li>
<li><a href="#5-add-unit-tests">5. Add Unit Tests</a></li>
<li><a href="#6-use-the-library">6. Use the Library</a></li>
</ul>
</li>
<li><a href="#library-types-and-patterns">Library Types and Patterns</a><ul>
<li><a href="#1-exception-library">1. Exception Library</a></li>
<li><a href="#2-configuration-library">2. Configuration Library</a></li>
<li><a href="#3-testing-utilities-library">3. Testing Utilities Library</a></li>
</ul>
</li>
<li><a href="#library-configuration">Library Configuration</a><ul>
<li><a href="#projectjson-options">Project.json Options</a></li>
<li><a href="#using-tags-for-boundaries">Using Tags for Boundaries</a></li>
</ul>
</li>
<li><a href="#testing-libraries">Testing Libraries</a><ul>
<li><a href="#run-library-tests">Run Library Tests</a></li>
<li><a href="#integration-testing">Integration Testing</a></li>
</ul>
</li>
<li><a href="#best-practices">Best Practices</a><ul>
<li><a href="#1-keep-libraries-focused">1. Keep Libraries Focused</a></li>
<li><a href="#2-define-clear-public-apis">2. Define Clear Public APIs</a></li>
<li><a href="#3-document-library-usage">3. Document Library Usage</a></li>
<li><a href="#4-version-libraries-if-publishable">4. Version Libraries (if publishable)</a></li>
<li><a href="#5-use-consistent-naming">5. Use Consistent Naming</a></li>
</ul>
</li>
<li><a href="#common-issues">Common Issues</a><ul>
<li><a href="#circular-dependencies">Circular Dependencies</a></li>
<li><a href="#build-order">Build Order</a></li>
<li><a href="#type-imports">Type Imports</a></li>
</ul>
</li>
<li><a href="#next-steps">Next Steps</a></li>
</ul>
<p>This guide explains how to create and configure shared libraries in the NX monorepo architecture.</p>
<h2 id="overview">Overview</h2>
<p>Libraries in NX are shared packages that can be used across multiple applications. They promote code reuse, maintain consistency, and enforce architectural boundaries.</p>
<h2 id="types-of-libraries">Types of Libraries</h2>
<h3 id="1-feature-libraries">1. Feature Libraries</h3>
<p>Contain business logic and UI components specific to a feature.</p>
<h3 id="2-data-access-libraries">2. Data Access Libraries</h3>
<p>Handle data fetching, state management, and API communication.</p>
<h3 id="3-utility-libraries">3. Utility Libraries</h3>
<p>Provide shared utilities, helpers, and common functions.</p>
<h3 id="4-ui-libraries">4. UI Libraries</h3>
<p>Contain presentational components and design system elements.</p>
<h2 id="creating-a-new-library">Creating a New Library</h2>
<h3 id="basic-library-generation">Basic Library Generation</h3>
<pre><code class="language-bash"># Generate a TypeScript library
nx g @nx/js:lib my-lib --directory=libs/shared

# Generate a NestJS library
nx g @nx/nest:lib my-nest-lib --directory=libs/backend

# Generate with specific options
nx g @nx/js:lib my-utils \
  --directory=libs/common \
  --tags=&quot;scope:shared,type:util&quot; \
  --publishable \
  --importPath=&quot;@app/my-utils&quot;
</code></pre>
<h3 id="library-structure">Library Structure</h3>
<p>After generation, your library structure will look like:</p>
<pre><code>libs/
‚îî‚îÄ‚îÄ common/
    ‚îî‚îÄ‚îÄ my-utils/
        ‚îú‚îÄ‚îÄ src/
        ‚îÇ   ‚îú‚îÄ‚îÄ index.ts          # Public API
        ‚îÇ   ‚îî‚îÄ‚îÄ lib/
        ‚îÇ       ‚îî‚îÄ‚îÄ my-utils.ts   # Implementation
        ‚îú‚îÄ‚îÄ project.json          # NX project configuration
        ‚îú‚îÄ‚îÄ tsconfig.json         # TypeScript config
        ‚îú‚îÄ‚îÄ tsconfig.lib.json     # Library-specific TS config
        ‚îú‚îÄ‚îÄ jest.config.ts        # Jest configuration
        ‚îî‚îÄ‚îÄ README.md             # Library documentation
</code></pre>
<h2 id="step-by-step-creating-a-validation-library">Step-by-Step: Creating a Validation Library</h2>
<p>Let&#39;s create a shared validation library as an example:</p>
<h3 id="1-generate-the-library">1. Generate the Library</h3>
<pre><code class="language-bash">nx g @nx/js:lib validation \
  --directory=libs/common \
  --tags=&quot;scope:shared,type:util&quot; \
  --importPath=&quot;@app/validation&quot;
</code></pre>
<h3 id="2-configure-typescript-path">2. Configure TypeScript Path</h3>
<p>The generator automatically adds the path mapping to <code>tsconfig.base.json</code>:</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;paths&quot;: {
      &quot;@app/validation&quot;: [&quot;libs/common/validation/src/index.ts&quot;]
    }
  }
}
</code></pre>
<h3 id="3-implement-library-code">3. Implement Library Code</h3>
<p>Create validation utilities in <code>libs/common/validation/src/lib/</code>:</p>
<pre><code class="language-typescript">// validation.ts
export function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  return emailRegex.test(email)
}

export function isValidUUID(uuid: string): boolean {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
  return uuidRegex.test(uuid)
}

export function isValidPassword(password: string): boolean {
  // At least 8 characters, one uppercase, one lowercase, one number
  const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&amp;]{8,}$/
  return passwordRegex.test(password)
}

// Custom validators for business logic
export function isValidProductSKU(sku: string): boolean {
  // Format: XXX-000-XXX (letters-numbers-letters)
  const skuRegex = /^[A-Z]{3}-\d{3}-[A-Z]{3}$/
  return skuRegex.test(sku)
}
</code></pre>
<h3 id="4-export-public-api">4. Export Public API</h3>
<p>Update <code>libs/common/validation/src/index.ts</code>:</p>
<pre><code class="language-typescript">export * from &#39;./lib/validation&#39;

// You can also export specific items
export { isValidEmail, isValidUUID } from &#39;./lib/validation&#39;
</code></pre>
<h3 id="5-add-unit-tests">5. Add Unit Tests</h3>
<p>Create <code>libs/common/validation/src/lib/validation.spec.ts</code>:</p>
<pre><code class="language-typescript">import { isValidEmail, isValidUUID, isValidPassword } from &#39;./validation&#39;

describe(&#39;Validation Utils&#39;, () =&gt; {
  describe(&#39;isValidEmail&#39;, () =&gt; {
    it(&#39;should validate correct emails&#39;, () =&gt; {
      expect(isValidEmail(&#39;user@example.com&#39;)).toBe(true)
      expect(isValidEmail(&#39;user.name+tag@example.co.uk&#39;)).toBe(true)
    })

    it(&#39;should reject invalid emails&#39;, () =&gt; {
      expect(isValidEmail(&#39;invalid&#39;)).toBe(false)
      expect(isValidEmail(&#39;@example.com&#39;)).toBe(false)
      expect(isValidEmail(&#39;user@&#39;)).toBe(false)
    })
  })

  describe(&#39;isValidUUID&#39;, () =&gt; {
    it(&#39;should validate v4 UUIDs&#39;, () =&gt; {
      expect(isValidUUID(&#39;550e8400-e29b-41d4-a716-446655440000&#39;)).toBe(true)
    })

    it(&#39;should reject invalid UUIDs&#39;, () =&gt; {
      expect(isValidUUID(&#39;not-a-uuid&#39;)).toBe(false)
      expect(isValidUUID(&#39;550e8400-e29b-11d4-a716-446655440000&#39;)).toBe(false) // v1 UUID
    })
  })
})
</code></pre>
<h3 id="6-use-the-library">6. Use the Library</h3>
<p>In any application or other library:</p>
<pre><code class="language-typescript">import { isValidEmail, isValidUUID } from &#39;@app/validation&#39;

@Injectable()
export class UsersService {
  async create(input: CreateUserInput) {
    // Use validation utilities
    if (!isValidEmail(input.email)) {
      throw new ValidationException(&#39;Invalid email format&#39;)
    }

    // Continue with creation...
  }

  async findOne(id: string) {
    if (!isValidUUID(id)) {
      throw new InvalidFormatException(&#39;Invalid user ID format&#39;)
    }

    return this.prisma.user.findUnique({ where: { id } })
  }
}
</code></pre>
<h2 id="library-types-and-patterns">Library Types and Patterns</h2>
<h3 id="1-exception-library">1. Exception Library</h3>
<pre><code class="language-bash">nx g @nx/js:lib exceptions --directory=libs/common
</code></pre>
<pre><code class="language-typescript">// libs/common/exceptions/src/lib/exceptions.ts
export class BaseException extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly statusCode: number
  ) {
    super(message)
    this.name = this.constructor.name
  }
}

export class ValidationException extends BaseException {
  constructor(message: string) {
    super(message, &#39;VALIDATION_ERROR&#39;, 400)
  }
}

export class NotFoundException extends BaseException {
  constructor(resource: string) {
    super(`${resource} not found`, &#39;NOT_FOUND&#39;, 404)
  }
}
</code></pre>
<h3 id="2-configuration-library">2. Configuration Library</h3>
<pre><code class="language-bash">nx g @nx/js:lib config --directory=libs/shared
</code></pre>
<pre><code class="language-typescript">// libs/shared/config/src/lib/config.ts
export interface DatabaseConfig {
  host: string
  port: number
  database: string
  username: string
  password: string
}

export interface AppConfig {
  port: number
  environment: &#39;development&#39; | &#39;production&#39; | &#39;test&#39;
  database: DatabaseConfig
}

export function loadConfig(): AppConfig {
  return {
    port: parseInt(process.env.PORT || &#39;3000&#39;, 10),
    environment: process.env.NODE_ENV as any || &#39;development&#39;,
    database: {
      host: process.env.DB_HOST || &#39;localhost&#39;,
      port: parseInt(process.env.DB_PORT || &#39;5432&#39;, 10),
      database: process.env.DB_NAME || &#39;myapp&#39;,
      username: process.env.DB_USER || &#39;postgres&#39;,
      password: process.env.DB_PASSWORD || &#39;postgres&#39;
    }
  }
}
</code></pre>
<h3 id="3-testing-utilities-library">3. Testing Utilities Library</h3>
<pre><code class="language-bash">nx g @nx/js:lib testing --directory=libs/common
</code></pre>
<pre><code class="language-typescript">// libs/common/testing/src/lib/mocks.ts
export function createMockUser(overrides?: Partial&lt;User&gt;): User {
  return {
    id: &#39;550e8400-e29b-41d4-a716-446655440000&#39;,
    email: &#39;test@example.com&#39;,
    name: &#39;Test User&#39;,
    createdAt: new Date(),
    updatedAt: new Date(),
    ...overrides
  }
}

export function createMockPrismaService() {
  return {
    user: {
      findMany: jest.fn(),
      findUnique: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
      delete: jest.fn()
    },
    product: {
      findMany: jest.fn(),
      findUnique: jest.fn(),
      create: jest.fn()
    }
  }
}
</code></pre>
<h2 id="library-configuration">Library Configuration</h2>
<h3 id="projectjson-options">Project.json Options</h3>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;validation&quot;,
  &quot;sourceRoot&quot;: &quot;libs/common/validation/src&quot;,
  &quot;projectType&quot;: &quot;library&quot;,
  &quot;targets&quot;: {
    &quot;build&quot;: {
      &quot;executor&quot;: &quot;@nx/js:tsc&quot;,
      &quot;outputs&quot;: [&quot;{options.outputPath}&quot;],
      &quot;options&quot;: {
        &quot;outputPath&quot;: &quot;dist/libs/common/validation&quot;,
        &quot;main&quot;: &quot;libs/common/validation/src/index.ts&quot;,
        &quot;tsConfig&quot;: &quot;libs/common/validation/tsconfig.lib.json&quot;,
        &quot;assets&quot;: [&quot;libs/common/validation/*.md&quot;]
      }
    },
    &quot;test&quot;: {
      &quot;executor&quot;: &quot;@nx/jest:jest&quot;,
      &quot;outputs&quot;: [&quot;{workspaceRoot}/coverage/{projectRoot}&quot;],
      &quot;options&quot;: {
        &quot;jestConfig&quot;: &quot;libs/common/validation/jest.config.ts&quot;
      }
    },
    &quot;lint&quot;: {
      &quot;executor&quot;: &quot;@nx/eslint:lint&quot;
    }
  },
  &quot;tags&quot;: [&quot;scope:shared&quot;, &quot;type:util&quot;]
}
</code></pre>
<h3 id="using-tags-for-boundaries">Using Tags for Boundaries</h3>
<p>Tags help enforce architectural constraints:</p>
<pre><code class="language-json">// .eslintrc.json
{
  &quot;overrides&quot;: [
    {
      &quot;files&quot;: [&quot;*.ts&quot;, &quot;*.tsx&quot;],
      &quot;rules&quot;: {
        &quot;@nx/enforce-module-boundaries&quot;: [
          &quot;error&quot;,
          {
            &quot;depConstraints&quot;: [
              {
                &quot;sourceTag&quot;: &quot;scope:backend&quot;,
                &quot;onlyDependOnLibsWithTags&quot;: [&quot;scope:shared&quot;, &quot;scope:backend&quot;]
              },
              {
                &quot;sourceTag&quot;: &quot;scope:shared&quot;,
                &quot;onlyDependOnLibsWithTags&quot;: [&quot;scope:shared&quot;]
              }
            ]
          }
        ]
      }
    }
  ]
}
</code></pre>
<h2 id="testing-libraries">Testing Libraries</h2>
<h3 id="run-library-tests">Run Library Tests</h3>
<pre><code class="language-bash"># Test specific library
nx test validation

# Test with coverage
nx test validation --coverage

# Test in watch mode
nx test validation --watch
</code></pre>
<h3 id="integration-testing">Integration Testing</h3>
<p>Test how libraries work together:</p>
<pre><code class="language-typescript">import { isValidEmail } from &#39;@app/validation&#39;
import { ValidationException } from &#39;@app/exceptions&#39;

describe(&#39;Library Integration&#39;, () =&gt; {
  it(&#39;should throw ValidationException for invalid email&#39;, () =&gt; {
    const invalidEmail = &#39;not-an-email&#39;
    
    if (!isValidEmail(invalidEmail)) {
      expect(() =&gt; {
        throw new ValidationException(&#39;Invalid email&#39;)
      }).toThrow(ValidationException)
    }
  })
})
</code></pre>
<h2 id="best-practices">Best Practices</h2>
<h3 id="1-keep-libraries-focused">1. Keep Libraries Focused</h3>
<p>Each library should have a single, clear purpose.</p>
<h3 id="2-define-clear-public-apis">2. Define Clear Public APIs</h3>
<p>Only export what consumers need:</p>
<pre><code class="language-typescript">// index.ts - be explicit about exports
export { isValidEmail, isValidUUID } from &#39;./lib/validation&#39;
// Don&#39;t export internal helpers
</code></pre>
<h3 id="3-document-library-usage">3. Document Library Usage</h3>
<p>Create a README.md for each library:</p>
<pre><code class="language-markdown"># Validation Library

Shared validation utilities for the monorepo.

## Installation

This library is available at `@app/validation`.

## Usage

\```typescript
import { isValidEmail } from &#39;@app/validation&#39;

if (!isValidEmail(email)) {
  throw new Error(&#39;Invalid email&#39;)
}
\```

## Available Functions

- `isValidEmail(email: string): boolean`
- `isValidUUID(uuid: string): boolean`
- `isValidPassword(password: string): boolean`
</code></pre>
<h3 id="4-version-libraries-if-publishable">4. Version Libraries (if publishable)</h3>
<p>For publishable libraries:</p>
<pre><code class="language-bash">nx g @nx/js:lib my-public-lib --publishable --importPath=&quot;@myorg/my-public-lib&quot;
</code></pre>
<h3 id="5-use-consistent-naming">5. Use Consistent Naming</h3>
<ul>
<li><code>libs/common/*</code> - Shared across all apps</li>
<li><code>libs/backend/*</code> - Backend-specific libraries</li>
<li><code>libs/frontend/*</code> - Frontend-specific libraries</li>
<li><code>libs/shared/*</code> - Business logic libraries</li>
</ul>
<h2 id="common-issues">Common Issues</h2>
<h3 id="circular-dependencies">Circular Dependencies</h3>
<p>Avoid by:</p>
<ul>
<li>Keep libraries focused</li>
<li>Use dependency inversion</li>
<li>Create interface libraries</li>
</ul>
<h3 id="build-order">Build Order</h3>
<p>NX automatically determines build order based on dependencies.</p>
<h3 id="type-imports">Type Imports</h3>
<p>Always use type imports when possible:</p>
<pre><code class="language-typescript">import type { User } from &#39;@app/interfaces&#39;
</code></pre>
<h2 id="next-steps">Next Steps</h2>
<ul>
<li>See <a href="#nx-monorepo-guide">NX Monorepo Guide</a> for workspace organization</li>
<li>Check <a href="#graphql-best-practices">GraphQL Best Practices</a> for using libraries in resolvers</li>
<li>Read <a href="#adding-new-service">Adding a New Service</a> for service-specific libraries</li>
</ul>
</div><div id="03-development-03-codegen-guide" class="doc-section"><h1 id="graphql-code-generator-guide">GraphQL Code Generator Guide</h1>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#overview">Overview</a><ul>
<li><a href="#what-gets-generated">What Gets Generated</a></li>
</ul>
</li>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#configuration">Configuration</a></li>
<li><a href="#running-code-generation">Running Code Generation</a></li>
<li><a href="#generated-files-overview">Generated Files Overview</a><ul>
<li><a href="#api-gateway">API Gateway</a></li>
<li><a href="#users-service">Users Service</a></li>
<li><a href="#products-service">Products Service</a></li>
</ul>
</li>
<li><a href="#verification-and-testing">Verification and Testing</a><ul>
<li><a href="#1-verify-generated-files">1. Verify Generated Files</a></li>
<li><a href="#2-test-typescript-integration">2. Test TypeScript Integration</a></li>
<li><a href="#3-verify-build">3. Verify Build</a></li>
</ul>
</li>
<li><a href="#usage-examples">Usage Examples</a><ul>
<li><a href="#using-generated-types-in-resolvers">Using Generated Types in Resolvers</a></li>
<li><a href="#using-types-in-services">Using Types in Services</a></li>
</ul>
</li>
<li><a href="#adding-new-graphql-operations">Adding New GraphQL Operations</a></li>
<li><a href="#troubleshooting">Troubleshooting</a><ul>
<li><a href="#services-not-running">Services Not Running</a></li>
<li><a href="#type-import-errors">Type Import Errors</a></li>
<li><a href="#outdated-types">Outdated Types</a></li>
<li><a href="#federation-type-errors">Federation Type Errors</a></li>
<li><a href="#prisma-type-mismatch">Prisma Type Mismatch</a></li>
</ul>
</li>
<li><a href="#best-practices">Best Practices</a></li>
<li><a href="#ide-tips">IDE Tips</a></li>
<li><a href="#next-steps">Next Steps</a></li>
</ul>
<h2 id="overview">Overview</h2>
<p>This project uses GraphQL Code Generator to generate TypeScript types from GraphQL schemas automatically. The codegen setup is configured to work with the NestJS code-first approach and Apollo Federation architecture.</p>
<h3 id="what-gets-generated">What Gets Generated</h3>
<ol>
<li><strong>Schema files</strong> - GraphQL schema files extracted from running services</li>
<li><strong>TypeScript types</strong> - Type definitions for GraphQL operations</li>
<li><strong>Resolver types</strong> - Typed resolver signatures with proper context and mappers</li>
<li><strong>Federation types</strong> - Apollo Federation specific types (I_Service, IQuery__EntitiesArgs)</li>
</ol>
<h2 id="prerequisites">Prerequisites</h2>
<p>Before running codegen, ensure all services are running:</p>
<pre><code class="language-bash"># Start all services
pnpm dev

# Or start them individually
pnpm start:users    # Port 3001
pnpm start:products # Port 3002
pnpm start:gateway  # Port 3000
</code></pre>
<h2 id="configuration">Configuration</h2>
<p>The codegen configuration is in <code>codegen.yml</code> at the project root. Key features:</p>
<ul>
<li><strong>Federation support</strong> - Properly handles Apollo Federation directives</li>
<li><strong>Prisma integration</strong> - Maps GraphQL types to Prisma models</li>
<li><strong>Custom scalars</strong> - DateTime mapped to string</li>
<li><strong>Context typing</strong> - Adds proper typing for resolver context</li>
<li><strong>Type prefixes</strong> - Uses &#39;I&#39; prefix for interfaces (IUser, IProduct)</li>
</ul>
<h2 id="running-code-generation">Running Code Generation</h2>
<pre><code class="language-bash"># Generate types once
pnpm codegen

# Watch mode - regenerates on schema changes
pnpm codegen:watch
</code></pre>
<h2 id="generated-files-overview">Generated Files Overview</h2>
<p>All generated files are in <code>*/generated/</code> directories and are git-ignored:</p>
<h3 id="api-gateway">API Gateway</h3>
<ul>
<li><code>apps/api-gateway/src/generated/gateway-schema.graphql</code> - Complete federated schema</li>
<li><code>apps/api-gateway/src/generated/graphql.ts</code> - TypeScript types for the gateway</li>
</ul>
<h3 id="users-service">Users Service</h3>
<ul>
<li><code>apps/users-service/src/generated/users-schema.graphql</code> - Users service schema</li>
<li><code>apps/users-service/src/generated/graphql.ts</code> - Typed resolvers with Prisma mappers</li>
</ul>
<h3 id="products-service">Products Service</h3>
<ul>
<li><code>apps/products-service/src/generated/products-schema.graphql</code> - Products service schema</li>
<li><code>apps/products-service/src/generated/graphql.ts</code> - Typed resolvers with Prisma mappers</li>
</ul>
<h2 id="verification-and-testing">Verification and Testing</h2>
<h3 id="1-verify-generated-files">1. Verify Generated Files</h3>
<pre><code class="language-bash"># List all generated files
find . -path &quot;*/generated/*&quot; -type f \( -name &quot;*.ts&quot; -o -name &quot;*.graphql&quot; \) | grep -v node_modules
</code></pre>
<p>Expected output:</p>
<pre><code>./apps/api-gateway/src/generated/gateway-schema.graphql
./apps/api-gateway/src/generated/graphql.ts
./apps/products-service/src/generated/graphql.ts
./apps/products-service/src/generated/products-schema.graphql
./apps/users-service/src/generated/graphql.ts
./apps/users-service/src/generated/users-schema.graphql
</code></pre>
<h3 id="2-test-typescript-integration">2. Test TypeScript Integration</h3>
<h4 id="auto-completion-test">Auto-completion Test</h4>
<ol>
<li>Open any resolver file in your IDE</li>
<li>Import types: <code>import { IResolvers } from &#39;../../generated/graphql&#39;</code></li>
<li>You should see auto-completion for all GraphQL types</li>
</ol>
<h4 id="type-validation-test">Type Validation Test</h4>
<p>Create a test file to verify types work correctly:</p>
<pre><code class="language-typescript">// test-types.ts
import { ICreateUserInput } from &#39;./apps/users-service/src/generated/graphql&#39;

// ‚úÖ This should work
const validInput: ICreateUserInput = {
  email: &#39;test@example.com&#39;,
  name: &#39;Test User&#39;,
  password: &#39;password123&#39;
}

// ‚ùå This should show TypeScript error
const invalidInput: ICreateUserInput = {
  email: &#39;test@example.com&#39;
  // Missing required fields!
}
</code></pre>
<h3 id="3-verify-build">3. Verify Build</h3>
<pre><code class="language-bash"># Build should succeed without type errors
pnpm build

# Run tests
pnpm test
</code></pre>
<h2 id="usage-examples">Usage Examples</h2>
<h3 id="using-generated-types-in-resolvers">Using Generated Types in Resolvers</h3>
<pre><code class="language-typescript">import { IResolvers, IMutationResolvers } from &#39;../../generated/graphql&#39;
import { User as PrismaUser } from &#39;@prisma/client-users&#39;

// Type individual resolver functions
const createUser: IMutationResolvers[&#39;createUser&#39;] = async (_, args, context) =&gt; {
  // args.createUserInput is fully typed!
  const user = await context.usersService.create(args.createUserInput)
  return toGraphQLUser(user)
}

// Helper to transform Prisma model to GraphQL type
const toGraphQLUser = (user: PrismaUser) =&gt; ({
  ...user,
  __typename: &#39;User&#39; as const
})
</code></pre>
<h3 id="using-types-in-services">Using Types in Services</h3>
<pre><code class="language-typescript">import { ICreateUserInput } from &#39;../../generated/graphql&#39;
import { User as PrismaUser } from &#39;@prisma/client-users&#39;

export class UsersService {
  async create(input: ICreateUserInput): Promise&lt;PrismaUser&gt; {
    // TypeScript ensures input has all required fields
    return this.prisma.user.create({
      data: {
        email: input.email,
        name: input.name,
        password: await hash(input.password, 10)
      }
    })
  }
}
</code></pre>
<h2 id="adding-new-graphql-operations">Adding New GraphQL Operations</h2>
<p>To add new queries or mutations:</p>
<ol>
<li><strong>Update your resolver</strong> with the new operation</li>
<li><strong>Restart the service</strong> to update the schema</li>
<li><strong>Run codegen</strong> to generate new types</li>
<li><strong>Use the generated types</strong> in your implementation</li>
</ol>
<p>Example:</p>
<pre><code class="language-typescript">@Query(() =&gt; [User])
async searchUsers(@Args(&#39;query&#39;) query: string) {
  // After codegen, IQueryResolvers will include &#39;searchUsers&#39;
  return this.usersService.search(query)
}
</code></pre>
<h2 id="troubleshooting">Troubleshooting</h2>
<h3 id="services-not-running">Services Not Running</h3>
<p><strong>Error</strong>: <code>Failed to load schema from http://localhost:300X/graphql</code></p>
<p><strong>Solution</strong>: Ensure all services are running:</p>
<pre><code class="language-bash">pnpm dev
</code></pre>
<h3 id="type-import-errors">Type Import Errors</h3>
<p><strong>Error</strong>: <code>Cannot find module &#39;./generated/graphql&#39;</code></p>
<p><strong>Solution</strong>: Run codegen after services are up:</p>
<pre><code class="language-bash">pnpm codegen
</code></pre>
<h3 id="outdated-types">Outdated Types</h3>
<p><strong>Problem</strong>: Types don&#39;t reflect recent schema changes</p>
<p><strong>Solution</strong>:</p>
<ol>
<li>Restart the service that changed</li>
<li>Run <code>pnpm codegen</code> again</li>
<li>Restart TypeScript server in IDE (Cmd/Ctrl + Shift + P ‚Üí &quot;Restart TS Server&quot;)</li>
</ol>
<h3 id="federation-type-errors">Federation Type Errors</h3>
<p><strong>Error</strong>: <code>Cannot find name &#39;I_Service&#39;</code> or <code>Cannot find name &#39;IQuery__EntitiesArgs&#39;</code></p>
<p><strong>Solution</strong>: These are imported from <code>@libs/codegen</code>. Ensure the import is present in generated files.</p>
<h3 id="prisma-type-mismatch">Prisma Type Mismatch</h3>
<p><strong>Error</strong>: Type conflicts between Prisma and GraphQL</p>
<p><strong>Solution</strong>: Regenerate Prisma clients first:</p>
<pre><code class="language-bash">pnpm prisma:generate:users
pnpm prisma:generate:products
pnpm codegen
</code></pre>
<h2 id="best-practices">Best Practices</h2>
<ol>
<li><strong>Run codegen after schema changes</strong> - Keep types synchronized</li>
<li><strong>Use the &#39;I&#39; prefix convention</strong> - All generated interfaces start with &#39;I&#39;</li>
<li><strong>Transform at resolver boundary</strong> - Convert Prisma models to GraphQL types in resolvers</li>
<li><strong>Commit generated files to .gitignore</strong> - They&#39;re rebuilt from source</li>
<li><strong>Add codegen to CI/CD</strong> - Ensure types are valid in production builds</li>
</ol>
<h2 id="ide-tips">IDE Tips</h2>
<ul>
<li><strong>VS Code</strong>: Install GraphQL extension for syntax highlighting</li>
<li><strong>WebStorm</strong>: Built-in GraphQL support</li>
<li><strong>Type Navigation</strong>: Cmd/Ctrl + Click on types to see definitions</li>
<li><strong>Auto-imports</strong>: Let IDE auto-import from generated files</li>
</ul>
<h2 id="next-steps">Next Steps</h2>
<ul>
<li>Read <a href="#codegen-best-practices">Code Generation Best Practices</a> for implementation patterns</li>
<li>See <a href="#graphql-best-practices">GraphQL Best Practices</a> for resolver patterns</li>
<li>Check <a href="#adding-new-service">Adding a New Service</a> for codegen setup in new services</li>
</ul>
</div><div id="04-best-practices-01-graphql-best-practices" class="doc-section"><h1 id="graphql-best-practices">GraphQL Best Practices</h1>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#resolver-architecture">Resolver Architecture</a><ul>
<li><a href="#the-hybrid-approach-nestjs-decorators-generated-types">The Hybrid Approach: NestJS Decorators + Generated Types</a></li>
<li><a href="#benefits-of-this-approach">Benefits of This Approach</a></li>
</ul>
</li>
<li><a href="#error-handling">Error Handling</a><ul>
<li><a href="#custom-graphql-exceptions">Custom GraphQL Exceptions</a></li>
<li><a href="#error-handling-pattern">Error Handling Pattern</a></li>
</ul>
</li>
<li><a href="#performance-optimization">Performance Optimization</a><ul>
<li><a href="#n1-query-prevention-with-dataloader">N+1 Query Prevention with DataLoader</a></li>
<li><a href="#query-complexity-analysis">Query Complexity Analysis</a></li>
<li><a href="#field-level-caching">Field-Level Caching</a></li>
</ul>
</li>
<li><a href="#federation-best-practices">Federation Best Practices</a><ul>
<li><a href="#entity-extension-pattern">Entity Extension Pattern</a></li>
<li><a href="#federation-directives">Federation Directives</a></li>
</ul>
</li>
<li><a href="#security-best-practices">Security Best Practices</a><ul>
<li><a href="#input-validation">Input Validation</a></li>
<li><a href="#rate-limiting">Rate Limiting</a></li>
<li><a href="#query-whitelisting">Query Whitelisting</a></li>
</ul>
</li>
<li><a href="#testing-strategies">Testing Strategies</a><ul>
<li><a href="#unit-testing-resolvers">Unit Testing Resolvers</a></li>
<li><a href="#integration-testing">Integration Testing</a></li>
</ul>
</li>
<li><a href="#monitoring-and-observability">Monitoring and Observability</a><ul>
<li><a href="#apollo-studio-integration">Apollo Studio Integration</a></li>
<li><a href="#custom-logging">Custom Logging</a></li>
</ul>
</li>
<li><a href="#schema-design-best-practices">Schema Design Best Practices</a><ul>
<li><a href="#naming-conventions">Naming Conventions</a></li>
<li><a href="#nullability">Nullability</a></li>
<li><a href="#pagination">Pagination</a></li>
</ul>
</li>
<li><a href="#common-pitfalls-to-avoid">Common Pitfalls to Avoid</a></li>
<li><a href="#next-steps">Next Steps</a></li>
</ul>
<h2 id="overview">Overview</h2>
<p>This guide covers best practices for implementing GraphQL APIs with NestJS, including resolver patterns, error handling, performance optimization, and testing strategies.</p>
<h2 id="resolver-architecture">Resolver Architecture</h2>
<h3 id="the-hybrid-approach-nestjs-decorators-generated-types">The Hybrid Approach: NestJS Decorators + Generated Types</h3>
<p>Combine the power of NestJS decorators with the type safety of generated types:</p>
<pre><code class="language-typescript">import { Resolver, Query, Mutation, Args } from &#39;@nestjs/graphql&#39;
import { UseGuards, UseInterceptors } from &#39;@nestjs/common&#39;
import { IUser, ICreateUserInput, IMutationResolvers } from &#39;../../generated/graphql&#39;

@Resolver(() =&gt; User)
export class UsersResolver {
  constructor(private readonly usersService: UsersService) {}

  @Query(() =&gt; [User], { name: &#39;users&#39; })
  @UseGuards(AuthGuard)  // NestJS features
  async findAll(): Promise&lt;IUser[]&gt; {  // Generated return type
    const users = await this.usersService.findAll()
    return users.map(this.toGraphQLUser)
  }

  @Mutation(() =&gt; User)
  async createUser(
    @Args(&#39;createUserInput&#39;) input: ICreateUserInput  // Generated input type
  ): ReturnType&lt;IMutationResolvers[&#39;createUser&#39;]&gt; {
    const user = await this.usersService.create(input)
    return this.toGraphQLUser(user)
  }
}
</code></pre>
<h3 id="benefits-of-this-approach">Benefits of This Approach</h3>
<ol>
<li>‚úÖ <strong>Full NestJS ecosystem</strong>: Guards, Interceptors, Pipes, Dependency Injection</li>
<li>‚úÖ <strong>Complete type safety</strong>: Generated types ensure schema compliance</li>
<li>‚úÖ <strong>Better developer experience</strong>: IDE support + NestJS features</li>
<li>‚úÖ <strong>Easy testing</strong>: Typed mocks and stubs</li>
<li>‚úÖ <strong>Gradual migration</strong>: Can adopt types incrementally</li>
</ol>
<h2 id="error-handling">Error Handling</h2>
<h3 id="custom-graphql-exceptions">Custom GraphQL Exceptions</h3>
<p>Create domain-specific exceptions that integrate with GraphQL:</p>
<pre><code class="language-typescript">import { GraphQLError } from &#39;graphql&#39;

export class GraphQLBusinessError extends GraphQLError {
  constructor(
    message: string,
    code: string,
    statusCode: number = 400,
    details?: Record&lt;string, any&gt;
  ) {
    super(message, {
      extensions: {
        code,
        statusCode,
        timestamp: new Date().toISOString(),
        ...details
      }
    })
  }
}

// Usage
throw new GraphQLBusinessError(
  &#39;Email already exists&#39;,
  &#39;DUPLICATE_EMAIL&#39;,
  409,
  { field: &#39;email&#39; }
)
</code></pre>
<h3 id="error-handling-pattern">Error Handling Pattern</h3>
<pre><code class="language-typescript">@Mutation(() =&gt; User)
async createUser(@Args(&#39;input&#39;) input: ICreateUserInput) {
  try {
    // Validation
    if (!isValidEmail(input.email)) {
      throw new ValidationError(&#39;Invalid email format&#39;)
    }

    // Business logic check
    const existing = await this.usersService.findByEmail(input.email)
    if (existing) {
      throw new ConflictError(&#39;Email already exists&#39;)
    }

    // Create user
    return await this.usersService.create(input)
    
  } catch (error) {
    // Log internal errors
    if (!(error instanceof GraphQLBusinessError)) {
      this.logger.error(&#39;Unexpected error&#39;, error)
      throw new InternalServerError(&#39;An unexpected error occurred&#39;)
    }
    throw error
  }
}
</code></pre>
<h2 id="performance-optimization">Performance Optimization</h2>
<h3 id="n1-query-prevention-with-dataloader">N+1 Query Prevention with DataLoader</h3>
<pre><code class="language-typescript">import DataLoader from &#39;dataloader&#39;

@Injectable()
export class UserLoader {
  constructor(private usersService: UsersService) {}

  createLoader(): DataLoader&lt;string, User&gt; {
    return new DataLoader(async (userIds: string[]) =&gt; {
      const users = await this.usersService.findByIds(userIds)
      const userMap = new Map(users.map(user =&gt; [user.id, user]))
      return userIds.map(id =&gt; userMap.get(id))
    })
  }
}

// In resolver
@ResolveField(() =&gt; User)
async user(@Parent() product: Product, @Context() context) {
  return context.userLoader.load(product.userId)
}
</code></pre>
<h3 id="query-complexity-analysis">Query Complexity Analysis</h3>
<pre><code class="language-typescript">import { GraphQLModule } from &#39;@nestjs/graphql&#39;
import depthLimit from &#39;graphql-depth-limit&#39;
import costAnalysis from &#39;graphql-cost-analysis&#39;

GraphQLModule.forRoot({
  validationRules: [
    depthLimit(5),  // Max query depth
    costAnalysis({
      maximumCost: 1000,
      defaultCost: 1,
      variables: {},
      createError: (max, actual) =&gt; {
        return new Error(`Query exceeded maximum cost of ${max}. Actual cost: ${actual}`)
      }
    })
  ]
})
</code></pre>
<h3 id="field-level-caching">Field-Level Caching</h3>
<pre><code class="language-typescript">import { CacheControl } from &#39;@nestjs/graphql&#39;

@Query(() =&gt; [Product])
@CacheControl({ maxAge: 60 })  // Cache for 60 seconds
async products() {
  return this.productsService.findAll()
}

@Query(() =&gt; User)
@CacheControl({ maxAge: 0, scope: &#39;PRIVATE&#39; })  // Don&#39;t cache user data
async me(@CurrentUser() user: User) {
  return user
}
</code></pre>
<h2 id="federation-best-practices">Federation Best Practices</h2>
<h3 id="entity-extension-pattern">Entity Extension Pattern</h3>
<pre><code class="language-typescript">// In Products service - extending User entity
@Resolver(() =&gt; User)
export class UserResolver {
  @ResolveField(() =&gt; [Product])
  async products(@Parent() user: User) {
    // Only fetch when requested
    return this.productsService.findByUserId(user.id)
  }

  @ResolveReference()
  async resolveReference(reference: { __typename: string; id: string }) {
    // Minimal data for federation
    return { id: reference.id, __typename: &#39;User&#39; }
  }
}
</code></pre>
<h3 id="federation-directives">Federation Directives</h3>
<pre><code class="language-typescript">@ObjectType()
@Directive(&#39;@key(fields: &quot;id&quot;)&#39;)
export class User {
  @Field(() =&gt; ID)
  id: string

  @Field()
  email: string

  // This field is resolved by another service
  @Field(() =&gt; [Product])
  @Directive(&#39;@external&#39;)
  products?: Product[]
}
</code></pre>
<h2 id="security-best-practices">Security Best Practices</h2>
<h3 id="input-validation">Input Validation</h3>
<pre><code class="language-typescript">import { IsEmail, Length, IsUUID } from &#39;class-validator&#39;

@InputType()
export class CreateUserInput {
  @Field()
  @IsEmail()
  email: string

  @Field()
  @Length(2, 50)
  name: string

  @Field()
  @Length(8, 100)
  password: string
}

// In resolver
@UsePipes(new ValidationPipe({ transform: true }))
@Mutation(() =&gt; User)
async createUser(@Args(&#39;input&#39;) input: CreateUserInput) {
  // Input is automatically validated
}
</code></pre>
<h3 id="rate-limiting">Rate Limiting</h3>
<pre><code class="language-typescript">import { ThrottlerGuard } from &#39;@nestjs/throttler&#39;

@Resolver()
@UseGuards(ThrottlerGuard)
export class PublicResolver {
  @Query(() =&gt; [Product])
  @Throttle(10, 60)  // 10 requests per minute
  async searchProducts(@Args(&#39;query&#39;) query: string) {
    return this.productsService.search(query)
  }
}
</code></pre>
<h3 id="query-whitelisting">Query Whitelisting</h3>
<pre><code class="language-typescript">// For production
GraphQLModule.forRoot({
  playground: false,
  introspection: false,
  persistedQueries: {
    cache: new InMemoryLRUCache({ maxSize: 1000 })
  },
  // Only allow pre-approved queries
  validationRules: [
    require(&#39;graphql-query-whitelist&#39;)({
      whitelist: loadWhitelistedQueries()
    })
  ]
})
</code></pre>
<h2 id="testing-strategies">Testing Strategies</h2>
<h3 id="unit-testing-resolvers">Unit Testing Resolvers</h3>
<pre><code class="language-typescript">import { Test } from &#39;@nestjs/testing&#39;
import { ICreateUserInput, IUser } from &#39;../../generated/graphql&#39;

describe(&#39;UsersResolver&#39;, () =&gt; {
  let resolver: UsersResolver
  let service: MockUsersService

  beforeEach(async () =&gt; {
    const module = await Test.createTestingModule({
      providers: [
        UsersResolver,
        {
          provide: UsersService,
          useValue: createMockUsersService()
        }
      ]
    }).compile()

    resolver = module.get(UsersResolver)
    service = module.get(UsersService)
  })

  it(&#39;should create user with valid input&#39;, async () =&gt; {
    const input: ICreateUserInput = {
      email: &#39;test@example.com&#39;,
      name: &#39;Test User&#39;,
      password: &#39;password123&#39;
    }

    const expectedUser: IUser = {
      id: &#39;123&#39;,
      ...input,
      __typename: &#39;User&#39;,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    }

    service.create.mockResolvedValue(expectedUser)

    const result = await resolver.createUser(input)
    expect(result).toEqual(expectedUser)
  })
})
</code></pre>
<h3 id="integration-testing">Integration Testing</h3>
<pre><code class="language-typescript">import { INestApplication } from &#39;@nestjs/common&#39;
import { GraphQLModule } from &#39;@nestjs/graphql&#39;
import request from &#39;supertest&#39;

describe(&#39;GraphQL Integration&#39;, () =&gt; {
  let app: INestApplication

  beforeAll(async () =&gt; {
    // Create app with real GraphQL setup
    app = await createTestApp()
  })

  it(&#39;should execute federated query&#39;, async () =&gt; {
    const query = `
      query {
        users {
          id
          name
          products {
            id
            name
            price
          }
        }
      }
    `

    const response = await request(app.getHttpServer())
      .post(&#39;/graphql&#39;)
      .send({ query })
      .expect(200)

    expect(response.body.data.users).toBeDefined()
    expect(response.body.errors).toBeUndefined()
  })
})
</code></pre>
<h2 id="monitoring-and-observability">Monitoring and Observability</h2>
<h3 id="apollo-studio-integration">Apollo Studio Integration</h3>
<pre><code class="language-typescript">import { ApolloServerPluginUsageReporting } from &#39;@apollo/server/plugin/usageReporting&#39;

GraphQLModule.forRoot({
  plugins: [
    ApolloServerPluginUsageReporting({
      sendVariableValues: { all: true },
      sendHeaders: { all: true }
    })
  ]
})
</code></pre>
<h3 id="custom-logging">Custom Logging</h3>
<pre><code class="language-typescript">@Injectable()
export class GraphQLLogger implements GraphQLPlugin {
  requestDidStart() {
    return {
      willSendResponse(context) {
        const { response, request } = context
        
        // Log queries with timing
        logger.info(&#39;GraphQL Request&#39;, {
          query: request.query,
          variables: request.variables,
          duration: response.http.body.extensions?.duration,
          errors: response.http.body.errors
        })
      }
    }
  }
}
</code></pre>
<h2 id="schema-design-best-practices">Schema Design Best Practices</h2>
<h3 id="naming-conventions">Naming Conventions</h3>
<pre><code class="language-graphql"># Good naming
type User {
  id: ID!
  email: String!
  createdAt: DateTime!  # Not &quot;created_at&quot; or &quot;dateCreated&quot;
}

input CreateUserInput {  # Not &quot;UserCreateInput&quot; or &quot;NewUser&quot;
  email: String!
  name: String!
}

type Query {
  user(id: ID!): User  # Singular for single item
  users: [User!]!      # Plural for lists
}

type Mutation {
  createUser(input: CreateUserInput!): User!  # Verb + Noun
  updateUser(input: UpdateUserInput!): User!
  deleteUser(id: ID!): User!
}
</code></pre>
<h3 id="nullability">Nullability</h3>
<pre><code class="language-graphql">type User {
  id: ID!              # Never null
  email: String!       # Required field
  bio: String          # Optional field
  posts: [Post!]!      # List never null, items never null
  friends: [User!]     # List can be null, items never null
}
</code></pre>
<h3 id="pagination">Pagination</h3>
<pre><code class="language-graphql">type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserEdge {
  node: User!
  cursor: String!
}

type Query {
  users(
    first: Int
    after: String
    last: Int
    before: String
  ): UserConnection!
}
</code></pre>
<h2 id="common-pitfalls-to-avoid">Common Pitfalls to Avoid</h2>
<ol>
<li><strong>Don&#39;t expose database IDs directly</strong> - Use opaque IDs or UUIDs</li>
<li><strong>Don&#39;t return null for lists</strong> - Return empty arrays instead</li>
<li><strong>Don&#39;t design around current UI</strong> - Design for API longevity</li>
<li><strong>Don&#39;t ignore deprecation</strong> - Mark old fields with @deprecated</li>
<li><strong>Don&#39;t skip error boundaries</strong> - Always handle errors gracefully</li>
</ol>
<h2 id="next-steps">Next Steps</h2>
<ul>
<li>Read <a href="#codegen-guide">Code Generation Guide</a> for type generation setup</li>
<li>See <a href="#codegen-best-practices">Code Generation Best Practices</a> for implementation patterns</li>
<li>Check <a href="#graphql-federation-guide">Federation Guide</a> for distributed schemas</li>
<li>Review <a href="#adding-new-service">Adding a New Service</a> for service setup</li>
</ul>
</div><div id="04-best-practices-02-codegen-best-practices" class="doc-section"><h1 id="graphql-code-generator-best-practices">GraphQL Code Generator Best Practices</h1>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#architecture-decision-prisma-types-vs-graphql-types">Architecture Decision: Prisma Types vs GraphQL Types</a><ul>
<li><a href="#core-principle">Core Principle</a></li>
<li><a href="#why-this-separation">Why This Separation?</a></li>
</ul>
</li>
<li><a href="#implementation-patterns">Implementation Patterns</a><ul>
<li><a href="#service-layer-pattern">Service Layer Pattern</a></li>
<li><a href="#resolver-layer-pattern">Resolver Layer Pattern</a></li>
</ul>
</li>
<li><a href="#transformation-helpers">Transformation Helpers</a><ul>
<li><a href="#when-to-use-transformation-helpers">When to Use Transformation Helpers</a></li>
<li><a href="#basic-transformation-pattern">Basic Transformation Pattern</a></li>
<li><a href="#advanced-transformation-with-computed-fields">Advanced Transformation with Computed Fields</a></li>
</ul>
</li>
<li><a href="#best-practices">Best Practices</a><ul>
<li><a href="#dos">Do&#39;s ‚úÖ</a></li>
<li><a href="#donts">Don&#39;ts ‚ùå</a></li>
</ul>
</li>
<li><a href="#federation-patterns">Federation Patterns</a><ul>
<li><a href="#extending-types-across-services">Extending Types Across Services</a></li>
<li><a href="#reference-resolvers">Reference Resolvers</a></li>
</ul>
</li>
<li><a href="#migration-strategy">Migration Strategy</a><ul>
<li><a href="#phase-1-generate-types">Phase 1: Generate Types</a></li>
<li><a href="#phase-2-add-type-imports">Phase 2: Add Type Imports</a></li>
<li><a href="#phase-3-type-methods-gradually">Phase 3: Type Methods Gradually</a></li>
<li><a href="#phase-4-add-transformations">Phase 4: Add Transformations</a></li>
</ul>
</li>
<li><a href="#common-patterns">Common Patterns</a><ul>
<li><a href="#pagination-with-type-safety">Pagination with Type Safety</a></li>
<li><a href="#error-handling">Error Handling</a></li>
<li><a href="#testing-with-generated-types">Testing with Generated Types</a></li>
</ul>
</li>
<li><a href="#development-workflow">Development Workflow</a></li>
<li><a href="#debugging-tips">Debugging Tips</a><ul>
<li><a href="#type-mismatch-errors">Type Mismatch Errors</a></li>
<li><a href="#missing-__typename">Missing __typename</a></li>
<li><a href="#date-serialization">Date Serialization</a></li>
</ul>
</li>
<li><a href="#performance-considerations">Performance Considerations</a><ul>
<li><a href="#batch-loading">Batch Loading</a></li>
<li><a href="#selective-fields">Selective Fields</a></li>
</ul>
</li>
<li><a href="#next-steps">Next Steps</a></li>
</ul>
<h2 id="overview">Overview</h2>
<p>This guide covers implementation patterns and best practices for using GraphQL Code Generator in a NestJS microservices architecture with Prisma ORM.</p>
<h2 id="architecture-decision-prisma-types-vs-graphql-types">Architecture Decision: Prisma Types vs GraphQL Types</h2>
<h3 id="core-principle">Core Principle</h3>
<p><strong>Service Layer</strong>: Use Prisma types (database models)<br><strong>Resolver Layer</strong>: Use GraphQL types (API contracts)</p>
<h3 id="why-this-separation">Why This Separation?</h3>
<ol>
<li><strong>Decoupling</strong> - API can evolve independently from database schema</li>
<li><strong>Flexibility</strong> - Hide internal fields, add computed properties</li>
<li><strong>Type Safety</strong> - Each layer has appropriate types for its purpose</li>
<li><strong>Maintainability</strong> - Clear boundaries between layers</li>
</ol>
<pre><code class="language-typescript">// ‚ùå Bad: GraphQL types in service
class UsersService {
  async findAll(): Promise&lt;IUser[]&gt; {  // IUser is GraphQL type
    return this.prisma.user.findMany()
  }
}

// ‚úÖ Good: Prisma types in service
class UsersService {
  async findAll(): Promise&lt;PrismaUser[]&gt; {  // PrismaUser is Prisma type
    return this.prisma.user.findMany()
  }
}
</code></pre>
<h2 id="implementation-patterns">Implementation Patterns</h2>
<h3 id="service-layer-pattern">Service Layer Pattern</h3>
<p>Services should work with Prisma types and focus on business logic:</p>
<pre><code class="language-typescript">import { Injectable } from &#39;@nestjs/common&#39;
import { PrismaService } from &#39;../prisma/prisma.service&#39;
import { User as PrismaUser } from &#39;@prisma/client-users&#39;
import { ICreateUserInput } from &#39;../../generated/graphql&#39;
import * as bcrypt from &#39;bcryptjs&#39;

@Injectable()
export class UsersService {
  constructor(private prisma: PrismaService) {}

  async findAll(): Promise&lt;PrismaUser[]&gt; {
    return this.prisma.user.findMany({
      orderBy: { createdAt: &#39;desc&#39; }
    })
  }

  async findOneById(id: string): Promise&lt;PrismaUser | null&gt; {
    return this.prisma.user.findUnique({
      where: { id }
    })
  }

  async create(input: ICreateUserInput): Promise&lt;PrismaUser&gt; {
    // Business logic: hash password
    const hashedPassword = await bcrypt.hash(input.password, 10)
    
    return this.prisma.user.create({
      data: {
        ...input,
        password: hashedPassword
      }
    })
  }
}
</code></pre>
<h3 id="resolver-layer-pattern">Resolver Layer Pattern</h3>
<p>Resolvers handle GraphQL concerns and type transformations:</p>
<pre><code class="language-typescript">import { Resolver, Query, Mutation, Args, ResolveField, Parent } from &#39;@nestjs/graphql&#39;
import { UsersService } from &#39;./users.service&#39;
import { User } from &#39;./entities/user.entity&#39;
import { 
  IQueryResolvers, 
  IMutationResolvers,
  IUserResolvers 
} from &#39;../../generated/graphql&#39;
import { User as PrismaUser } from &#39;@prisma/client-users&#39;

@Resolver(() =&gt; User)
export class UsersResolver {
  constructor(private readonly usersService: UsersService) {}

  @Query(() =&gt; [User], { name: &#39;users&#39; })
  async findAll(): ReturnType&lt;IQueryResolvers[&#39;users&#39;]&gt; {
    const users = await this.usersService.findAll()
    return users.map(user =&gt; this.toGraphQLUser(user))
  }

  @Mutation(() =&gt; User)
  async createUser(
    @Args(&#39;createUserInput&#39;) createUserInput: Parameters&lt;IMutationResolvers[&#39;createUser&#39;]&gt;[1][&#39;createUserInput&#39;]
  ): ReturnType&lt;IMutationResolvers[&#39;createUser&#39;]&gt; {
    const user = await this.usersService.create(createUserInput)
    return this.toGraphQLUser(user)
  }

  // Transform Prisma model to GraphQL type
  private toGraphQLUser(user: PrismaUser) {
    return {
      ...user,
      __typename: &#39;User&#39; as const
    }
  }
}
</code></pre>
<h2 id="transformation-helpers">Transformation Helpers</h2>
<h3 id="when-to-use-transformation-helpers">When to Use Transformation Helpers</h3>
<p>Use transformation helpers when:</p>
<ul>
<li>Converting between Prisma and GraphQL types</li>
<li>Adding computed fields</li>
<li>Hiding sensitive data</li>
<li>Formatting dates or other values</li>
</ul>
<h3 id="basic-transformation-pattern">Basic Transformation Pattern</h3>
<pre><code class="language-typescript">// Transform single entity
function toGraphQLUser(user: PrismaUser): IUser {
  return {
    id: user.id,
    email: user.email,
    name: user.name,
    createdAt: user.createdAt.toISOString(), // Date to string
    updatedAt: user.updatedAt.toISOString(),
    __typename: &#39;User&#39; as const
  }
}

// Transform arrays
function toGraphQLUsers(users: PrismaUser[]): IUser[] {
  return users.map(toGraphQLUser)
}
</code></pre>
<h3 id="advanced-transformation-with-computed-fields">Advanced Transformation with Computed Fields</h3>
<pre><code class="language-typescript">function toGraphQLProduct(product: PrismaProduct &amp; { _count?: { orders: number } }): IProduct {
  return {
    id: product.id,
    name: product.name,
    price: product.price,
    stock: product.stock,
    // Computed field
    isAvailable: product.stock &gt; 0,
    // Optional count from Prisma
    orderCount: product._count?.orders ?? 0,
    createdAt: product.createdAt.toISOString(),
    updatedAt: product.updatedAt.toISOString(),
    __typename: &#39;Product&#39; as const
  }
}
</code></pre>
<h2 id="best-practices">Best Practices</h2>
<h3 id="dos">Do&#39;s ‚úÖ</h3>
<ol>
<li><p><strong>Type Everything Explicitly</strong></p>
<pre><code class="language-typescript">// Explicitly type resolver methods
const createUser: IMutationResolvers[&#39;createUser&#39;] = async (_, args, context) =&gt; {
  // Implementation
}
</code></pre>
</li>
<li><p><strong>Use Type Imports</strong></p>
<pre><code class="language-typescript">import type { IUser, ICreateUserInput } from &#39;../../generated/graphql&#39;
</code></pre>
</li>
<li><p><strong>Validate Input at Resolver Level</strong></p>
<pre><code class="language-typescript">if (!isValidUUID(args.id)) {
  throw new InvalidFormatException(&#39;Invalid user ID format&#39;)
}
</code></pre>
</li>
<li><p><strong>Keep Transformations Simple</strong></p>
<pre><code class="language-typescript">// One transformation function per entity type
const toGraphQLUser = (user: PrismaUser): IUser =&gt; ({
  ...user,
  __typename: &#39;User&#39; as const
})
</code></pre>
</li>
<li><p><strong>Use Generated Enums</strong></p>
<pre><code class="language-typescript">import { IOrderStatus } from &#39;../../generated/graphql&#39;

if (status === IOrderStatus.Completed) {
  // Handle completed order
}
</code></pre>
</li>
</ol>
<h3 id="donts">Don&#39;ts ‚ùå</h3>
<ol>
<li><p><strong>Don&#39;t Use GraphQL Types in Services</strong></p>
<pre><code class="language-typescript">// ‚ùå Bad
class ProductService {
  async findAll(): Promise&lt;IProduct[]&gt; {
    return this.prisma.product.findMany()
  }
}
</code></pre>
</li>
<li><p><strong>Don&#39;t Ignore Type Errors</strong></p>
<pre><code class="language-typescript">// ‚ùå Bad
return user as any

// ‚úÖ Good
return toGraphQLUser(user)
</code></pre>
</li>
<li><p><strong>Don&#39;t Mix Layers</strong></p>
<pre><code class="language-typescript">// ‚ùå Bad: Prisma query in resolver
@Query()
async users() {
  return this.prisma.user.findMany()
}

// ‚úÖ Good: Use service
@Query()
async users() {
  const users = await this.usersService.findAll()
  return users.map(toGraphQLUser)
}
</code></pre>
</li>
</ol>
<h2 id="federation-patterns">Federation Patterns</h2>
<h3 id="extending-types-across-services">Extending Types Across Services</h3>
<pre><code class="language-typescript">// In Products service - extending User type
@Resolver(() =&gt; User)
export class UserResolver {
  constructor(private readonly productsService: ProductsService) {}

  @ResolveField(() =&gt; [Product])
  async products(
    @Parent() user: User
  ): ReturnType&lt;IUserResolvers[&#39;products&#39;]&gt; {
    const products = await this.productsService.findByUserId(user.id)
    return products.map(toGraphQLProduct)
  }
}
</code></pre>
<h3 id="reference-resolvers">Reference Resolvers</h3>
<pre><code class="language-typescript">@Resolver(() =&gt; User)
export class UserResolver {
  @ResolveReference()
  async resolveReference(
    reference: { __typename: string; id: string }
  ): Promise&lt;IUser | null&gt; {
    const user = await this.usersService.findOneById(reference.id)
    return user ? toGraphQLUser(user) : null
  }
}
</code></pre>
<h2 id="migration-strategy">Migration Strategy</h2>
<p>For existing projects, migrate progressively:</p>
<h3 id="phase-1-generate-types">Phase 1: Generate Types</h3>
<pre><code class="language-bash">pnpm codegen
</code></pre>
<h3 id="phase-2-add-type-imports">Phase 2: Add Type Imports</h3>
<pre><code class="language-typescript">// Start by importing types without changing logic
import type { IUser, ICreateUserInput } from &#39;./generated/graphql&#39;
</code></pre>
<h3 id="phase-3-type-methods-gradually">Phase 3: Type Methods Gradually</h3>
<pre><code class="language-typescript">// Type one resolver at a time
const findAll: IQueryResolvers[&#39;users&#39;] = async () =&gt; {
  // Existing implementation
}
</code></pre>
<h3 id="phase-4-add-transformations">Phase 4: Add Transformations</h3>
<pre><code class="language-typescript">// Add transformation helpers
const users = await this.usersService.findAll()
return users.map(toGraphQLUser)
</code></pre>
<h2 id="common-patterns">Common Patterns</h2>
<h3 id="pagination-with-type-safety">Pagination with Type Safety</h3>
<pre><code class="language-typescript">interface PaginationArgs {
  limit: number
  offset: number
}

const users: IQueryResolvers[&#39;users&#39;] = async (_, args: PaginationArgs) =&gt; {
  const users = await this.prisma.user.findMany({
    take: args.limit,
    skip: args.offset,
    orderBy: { createdAt: &#39;desc&#39; }
  })
  
  return {
    items: users.map(toGraphQLUser),
    total: await this.prisma.user.count(),
    hasMore: users.length === args.limit
  }
}
</code></pre>
<h3 id="error-handling">Error Handling</h3>
<pre><code class="language-typescript">const createUser: IMutationResolvers[&#39;createUser&#39;] = async (_, args, context) =&gt; {
  try {
    // Validate input
    if (!isValidEmail(args.createUserInput.email)) {
      throw new ValidationException(&#39;Invalid email format&#39;)
    }
    
    // Check uniqueness
    const existing = await context.usersService.findByEmail(args.createUserInput.email)
    if (existing) {
      throw new ConflictException(&#39;Email already exists&#39;)
    }
    
    // Create user
    const user = await context.usersService.create(args.createUserInput)
    return toGraphQLUser(user)
    
  } catch (error) {
    // Re-throw known errors
    if (error instanceof BaseException) {
      throw error
    }
    // Wrap unknown errors
    throw new InternalServerErrorException(&#39;Failed to create user&#39;)
  }
}
</code></pre>
<h3 id="testing-with-generated-types">Testing with Generated Types</h3>
<pre><code class="language-typescript">import { ICreateUserInput } from &#39;../../generated/graphql&#39;

describe(&#39;UsersService&#39;, () =&gt; {
  it(&#39;should create a user&#39;, async () =&gt; {
    const input: ICreateUserInput = {
      email: &#39;test@example.com&#39;,
      name: &#39;Test User&#39;,
      password: &#39;password123&#39;
    }
    
    const user = await service.create(input)
    expect(user.email).toBe(input.email)
  })
})
</code></pre>
<h2 id="development-workflow">Development Workflow</h2>
<ol>
<li><strong>Define/Update GraphQL Schema</strong> (using decorators)</li>
<li><strong>Run Services</strong> to expose schemas</li>
<li><strong>Generate Types</strong> with <code>pnpm codegen</code></li>
<li><strong>Implement with Types</strong> using patterns above</li>
<li><strong>Test</strong> with full type safety</li>
</ol>
<h2 id="debugging-tips">Debugging Tips</h2>
<h3 id="type-mismatch-errors">Type Mismatch Errors</h3>
<pre><code class="language-typescript">// If you see: Type &#39;PrismaUser&#39; is not assignable to type &#39;IUser&#39;
// Solution: Use transformation helper
return toGraphQLUser(prismaUser)
</code></pre>
<h3 id="missing-__typename">Missing __typename</h3>
<pre><code class="language-typescript">// Always include __typename in transformations
return {
  ...user,
  __typename: &#39;User&#39; as const  // Required for Apollo Client
}
</code></pre>
<h3 id="date-serialization">Date Serialization</h3>
<pre><code class="language-typescript">// Dates must be strings in GraphQL
createdAt: user.createdAt.toISOString()
</code></pre>
<h2 id="performance-considerations">Performance Considerations</h2>
<h3 id="batch-loading">Batch Loading</h3>
<pre><code class="language-typescript">// Use DataLoader for N+1 query prevention
@ResolveField(() =&gt; User)
async user(@Parent() product: Product) {
  return this.userLoader.load(product.userId)
}
</code></pre>
<h3 id="selective-fields">Selective Fields</h3>
<pre><code class="language-typescript">// Only select needed fields from database
async findAll(fields?: string[]) {
  return this.prisma.user.findMany({
    select: fields ? 
      Object.fromEntries(fields.map(f =&gt; [f, true])) : 
      undefined
  })
}
</code></pre>
<h2 id="next-steps">Next Steps</h2>
<ul>
<li>Read <a href="#graphql-best-practices">GraphQL Best Practices</a> for more resolver patterns</li>
<li>See <a href="#nx-monorepo-guide">NX Monorepo Guide</a> for project structure</li>
<li>Check <a href="#graphql-federation-guide">Federation Guide</a> for distributed schemas</li>
</ul>
</div><div id="04-best-practices-03-security" class="doc-section"><h1 id="security-best-practices">Security Best Practices</h1>
<p>This guide covers security best practices for the NestJS GraphQL Microservices architecture, focusing on defensive security measures.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#authentication-authorization">Authentication &amp; Authorization</a></li>
<li><a href="#input-validation-sanitization">Input Validation &amp; Sanitization</a></li>
<li><a href="#graphql-security">GraphQL Security</a></li>
<li><a href="#database-security">Database Security</a></li>
<li><a href="#api-security">API Security</a></li>
<li><a href="#infrastructure-security">Infrastructure Security</a></li>
<li><a href="#dependency-security">Dependency Security</a></li>
<li><a href="#monitoring-auditing">Monitoring &amp; Auditing</a></li>
<li><a href="#security-checklist">Security Checklist</a></li>
</ul>
<h2 id="authentication-authorization">Authentication &amp; Authorization</h2>
<h3 id="jwt-implementation">JWT Implementation</h3>
<pre><code class="language-typescript">// libs/auth/src/lib/jwt.strategy.ts
import { Injectable } from &#39;@nestjs/common&#39;
import { PassportStrategy } from &#39;@nestjs/passport&#39;
import { ExtractJwt, Strategy } from &#39;passport-jwt&#39;

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get(&#39;JWT_SECRET&#39;),
      algorithms: [&#39;HS256&#39;], // Specify allowed algorithms
    })
  }

  async validate(payload: any) {
    // Minimal data in token
    return { userId: payload.sub, email: payload.email, roles: payload.roles }
  }
}
</code></pre>
<h3 id="role-based-access-control-rbac">Role-Based Access Control (RBAC)</h3>
<pre><code class="language-typescript">// libs/auth/src/lib/roles.guard.ts
@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride&lt;Role[]&gt;(&#39;roles&#39;, [
      context.getHandler(),
      context.getClass(),
    ])
    
    if (!requiredRoles) {
      return true
    }
    
    const { user } = context.switchToHttp().getRequest()
    return requiredRoles.some((role) =&gt; user.roles?.includes(role))
  }
}

// Usage in resolver
@Roles(&#39;admin&#39;)
@UseGuards(JwtAuthGuard, RolesGuard)
@Mutation(() =&gt; User)
async deleteUser(@Args(&#39;id&#39;) id: string) {
  return this.usersService.delete(id)
}
</code></pre>
<h3 id="password-security">Password Security</h3>
<pre><code class="language-typescript">// libs/auth/src/lib/password.service.ts
import * as bcrypt from &#39;bcryptjs&#39;
import { Injectable } from &#39;@nestjs/common&#39;

@Injectable()
export class PasswordService {
  private readonly rounds = 12 // Adjust based on performance needs

  async hash(password: string): Promise&lt;string&gt; {
    // Validate password strength
    this.validatePasswordStrength(password)
    return bcrypt.hash(password, this.rounds)
  }

  async compare(password: string, hash: string): Promise&lt;boolean&gt; {
    return bcrypt.compare(password, hash)
  }

  private validatePasswordStrength(password: string): void {
    const minLength = 8
    const hasUpperCase = /[A-Z]/.test(password)
    const hasLowerCase = /[a-z]/.test(password)
    const hasNumbers = /\d/.test(password)
    const hasSpecialChar = /[!@#$%^&amp;*]/.test(password)

    if (password.length &lt; minLength) {
      throw new Error(&#39;Password must be at least 8 characters long&#39;)
    }

    if (!hasUpperCase || !hasLowerCase || !hasNumbers) {
      throw new Error(&#39;Password must contain uppercase, lowercase, and numbers&#39;)
    }

    // Check against common passwords
    if (this.isCommonPassword(password)) {
      throw new Error(&#39;Password is too common&#39;)
    }
  }

  private isCommonPassword(password: string): boolean {
    const commonPasswords = [&#39;password&#39;, &#39;12345678&#39;, &#39;qwerty&#39;, &#39;admin&#39;]
    return commonPasswords.some(common =&gt; 
      password.toLowerCase().includes(common)
    )
  }
}
</code></pre>
<h3 id="session-management">Session Management</h3>
<pre><code class="language-typescript">// Secure session configuration
@Injectable()
export class SessionService {
  private readonly sessionStore = new Map&lt;string, SessionData&gt;()
  private readonly sessionTimeout = 30 * 60 * 1000 // 30 minutes

  async createSession(userId: string): Promise&lt;string&gt; {
    const sessionId = this.generateSecureToken()
    const expiresAt = Date.now() + this.sessionTimeout
    
    this.sessionStore.set(sessionId, {
      userId,
      createdAt: Date.now(),
      expiresAt,
      lastActivity: Date.now()
    })

    // Clean expired sessions periodically
    this.cleanExpiredSessions()
    
    return sessionId
  }

  private generateSecureToken(): string {
    return crypto.randomBytes(32).toString(&#39;hex&#39;)
  }

  private cleanExpiredSessions(): void {
    const now = Date.now()
    for (const [id, session] of this.sessionStore.entries()) {
      if (session.expiresAt &lt; now) {
        this.sessionStore.delete(id)
      }
    }
  }
}
</code></pre>
<h2 id="input-validation-sanitization">Input Validation &amp; Sanitization</h2>
<h3 id="dto-validation">DTO Validation</h3>
<pre><code class="language-typescript">import { IsEmail, IsString, Length, Matches, IsUUID } from &#39;class-validator&#39;
import { Transform } from &#39;class-transformer&#39;

export class CreateUserInput {
  @IsEmail()
  @Transform(({ value }) =&gt; value.toLowerCase().trim())
  email: string

  @IsString()
  @Length(2, 50)
  @Transform(({ value }) =&gt; value.trim())
  @Matches(/^[a-zA-Z\s&#39;-]+$/, {
    message: &#39;Name can only contain letters, spaces, hyphens, and apostrophes&#39;
  })
  name: string

  @IsString()
  @Length(8, 128)
  @Matches(
    /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&amp;])[A-Za-z\d@$!%*?&amp;]/,
    {
      message: &#39;Password must contain uppercase, lowercase, number, and special character&#39;
    }
  )
  password: string
}

// Global validation pipe
app.useGlobalPipes(new ValidationPipe({
  whitelist: true, // Strip unknown properties
  forbidNonWhitelisted: true, // Throw error on unknown properties
  transform: true, // Auto-transform types
  transformOptions: {
    enableImplicitConversion: false // Explicit conversions only
  }
}))
</code></pre>
<h3 id="sql-injection-prevention">SQL Injection Prevention</h3>
<pre><code class="language-typescript">// Using Prisma (automatically parameterized)
async findByEmail(email: string) {
  // Safe - Prisma handles parameterization
  return this.prisma.user.findUnique({
    where: { email }
  })
}

// If using raw SQL, always parameterize
async searchUsers(searchTerm: string) {
  // Safe - using parameterized query
  return this.prisma.$queryRaw`
    SELECT * FROM &quot;User&quot; 
    WHERE name ILIKE ${`%${searchTerm}%`}
    LIMIT 10
  `
}

// Never do this
async unsafeSearch(term: string) {
  // DANGER: SQL injection vulnerability
  return this.prisma.$queryRawUnsafe(
    `SELECT * FROM &quot;User&quot; WHERE name LIKE &#39;%${term}%&#39;`
  )
}
</code></pre>
<h3 id="xss-prevention">XSS Prevention</h3>
<pre><code class="language-typescript">import DOMPurify from &#39;isomorphic-dompurify&#39;

@Injectable()
export class SanitizationService {
  sanitizeHtml(input: string): string {
    return DOMPurify.sanitize(input, {
      ALLOWED_TAGS: [&#39;b&#39;, &#39;i&#39;, &#39;em&#39;, &#39;strong&#39;, &#39;p&#39;, &#39;br&#39;],
      ALLOWED_ATTR: []
    })
  }

  sanitizeForGraphQL(input: string): string {
    // Remove potential GraphQL injection attempts
    return input
      .replace(/[{}]/g, &#39;&#39;) // Remove braces
      .replace(/\$/g, &#39;&#39;) // Remove dollar signs
      .replace(/\.\./g, &#39;&#39;) // Remove path traversal
  }

  escapeHtml(unsafe: string): string {
    return unsafe
      .replace(/&amp;/g, &quot;&amp;amp;&quot;)
      .replace(/&lt;/g, &quot;&amp;lt;&quot;)
      .replace(/&gt;/g, &quot;&amp;gt;&quot;)
      .replace(/&quot;/g, &quot;&amp;quot;&quot;)
      .replace(/&#39;/g, &quot;&amp;#039;&quot;)
  }
}
</code></pre>
<h2 id="graphql-security">GraphQL Security</h2>
<h3 id="query-depth-limiting">Query Depth Limiting</h3>
<pre><code class="language-typescript">import depthLimit from &#39;graphql-depth-limit&#39;

GraphQLModule.forRoot({
  validationRules: [
    depthLimit(5, { 
      ignore: [&#39;__schema&#39;, &#39;__type&#39;] // Allow introspection queries
    })
  ],
  playground: process.env.NODE_ENV !== &#39;production&#39;,
  introspection: process.env.NODE_ENV !== &#39;production&#39;,
})
</code></pre>
<h3 id="query-complexity-analysis">Query Complexity Analysis</h3>
<pre><code class="language-typescript">import costAnalysis from &#39;graphql-cost-analysis&#39;

GraphQLModule.forRoot({
  validationRules: [
    costAnalysis({
      maximumCost: 1000,
      defaultCost: 1,
      variables: {},
      createError: (max, actual) =&gt; {
        return new Error(
          `Query validation error: Cost ${actual} exceeds maximum cost ${max}`
        )
      },
      onComplete: (cost) =&gt; {
        console.log(`Query cost: ${cost}`)
      }
    })
  ]
})
</code></pre>
<h3 id="rate-limiting">Rate Limiting</h3>
<pre><code class="language-typescript">import { ThrottlerModule } from &#39;@nestjs/throttler&#39;

@Module({
  imports: [
    ThrottlerModule.forRoot({
      ttl: 60, // Time window in seconds
      limit: 10, // Number of requests
      skipIf: (context) =&gt; {
        // Skip rate limiting for authenticated admin users
        const request = context.switchToHttp().getRequest()
        return request.user?.roles?.includes(&#39;admin&#39;)
      }
    })
  ]
})

// Custom rate limits for specific operations
@Throttle(3, 60) // 3 requests per minute
@Mutation(() =&gt; User)
async resetPassword(@Args(&#39;email&#39;) email: string) {
  // Password reset logic
}
</code></pre>
<h3 id="field-level-security">Field-Level Security</h3>
<pre><code class="language-typescript">@ObjectType()
export class User {
  @Field(() =&gt; ID)
  id: string

  @Field()
  email: string

  @Field()
  name: string

  // Never expose sensitive fields
  // @Field() // DON&#39;T DO THIS
  password: string

  @Field({ nullable: true })
  @Authorized([&#39;admin&#39;]) // Only admins can see this field
  lastLoginIp?: string

  @Field(() =&gt; [String])
  @Authorized() // Only authenticated users
  roles: string[]
}
</code></pre>
<h2 id="database-security">Database Security</h2>
<h3 id="connection-security">Connection Security</h3>
<pre><code class="language-env"># Use SSL for database connections
DATABASE_URL=&quot;postgresql://user:pass@host:5432/db?schema=public&amp;sslmode=require&quot;

# Separate read/write connections
DATABASE_URL_READ=&quot;postgresql://readonly_user:pass@host:5432/db&quot;
DATABASE_URL_WRITE=&quot;postgresql://write_user:pass@host:5432/db&quot;
</code></pre>
<h3 id="data-encryption">Data Encryption</h3>
<pre><code class="language-typescript">import { createCipheriv, createDecipheriv, randomBytes } from &#39;crypto&#39;

@Injectable()
export class EncryptionService {
  private algorithm = &#39;aes-256-gcm&#39;
  private key = Buffer.from(process.env.ENCRYPTION_KEY, &#39;hex&#39;)

  encrypt(text: string): { encrypted: string; iv: string; tag: string } {
    const iv = randomBytes(16)
    const cipher = createCipheriv(this.algorithm, this.key, iv)
    
    let encrypted = cipher.update(text, &#39;utf8&#39;, &#39;hex&#39;)
    encrypted += cipher.final(&#39;hex&#39;)
    
    const tag = cipher.getAuthTag()
    
    return {
      encrypted,
      iv: iv.toString(&#39;hex&#39;),
      tag: tag.toString(&#39;hex&#39;)
    }
  }

  decrypt(encrypted: string, iv: string, tag: string): string {
    const decipher = createDecipheriv(
      this.algorithm,
      this.key,
      Buffer.from(iv, &#39;hex&#39;)
    )
    
    decipher.setAuthTag(Buffer.from(tag, &#39;hex&#39;))
    
    let decrypted = decipher.update(encrypted, &#39;hex&#39;, &#39;utf8&#39;)
    decrypted += decipher.final(&#39;utf8&#39;)
    
    return decrypted
  }
}
</code></pre>
<h3 id="audit-logging">Audit Logging</h3>
<pre><code class="language-typescript">@Injectable()
export class AuditService {
  async logDataAccess(
    userId: string,
    resource: string,
    action: string,
    metadata?: any
  ) {
    await this.prisma.auditLog.create({
      data: {
        userId,
        resource,
        action,
        metadata: metadata ? JSON.stringify(metadata) : null,
        ipAddress: this.getClientIp(),
        userAgent: this.getUserAgent(),
        timestamp: new Date()
      }
    })
  }

  // Log sensitive operations
  @LogAccess(&#39;User&#39;, &#39;READ_SENSITIVE&#39;)
  async getUserWithSensitiveData(id: string) {
    // Implementation
  }
}
</code></pre>
<h2 id="api-security">API Security</h2>
<h3 id="cors-configuration">CORS Configuration</h3>
<pre><code class="language-typescript">app.enableCors({
  origin: (origin, callback) =&gt; {
    const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(&#39;,&#39;) || []
    
    // Allow requests with no origin (mobile apps, Postman)
    if (!origin) return callback(null, true)
    
    if (allowedOrigins.includes(origin)) {
      callback(null, true)
    } else {
      callback(new Error(&#39;Not allowed by CORS&#39;))
    }
  },
  credentials: true,
  methods: [&#39;GET&#39;, &#39;POST&#39;],
  allowedHeaders: [&#39;Content-Type&#39;, &#39;Authorization&#39;],
  maxAge: 86400 // 24 hours
})
</code></pre>
<h3 id="security-headers">Security Headers</h3>
<pre><code class="language-typescript">import helmet from &#39;helmet&#39;

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: [&quot;&#39;self&#39;&quot;],
      styleSrc: [&quot;&#39;self&#39;&quot;, &quot;&#39;unsafe-inline&#39;&quot;],
      scriptSrc: [&quot;&#39;self&#39;&quot;],
      imgSrc: [&quot;&#39;self&#39;&quot;, &quot;data:&quot;, &quot;https:&quot;],
      connectSrc: [&quot;&#39;self&#39;&quot;],
      fontSrc: [&quot;&#39;self&#39;&quot;],
      objectSrc: [&quot;&#39;none&#39;&quot;],
      mediaSrc: [&quot;&#39;self&#39;&quot;],
      frameSrc: [&quot;&#39;none&#39;&quot;]
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}))
</code></pre>
<h3 id="api-key-management">API Key Management</h3>
<pre><code class="language-typescript">@Injectable()
export class ApiKeyGuard implements CanActivate {
  constructor(
    private configService: ConfigService,
    private cryptoService: CryptoService
  ) {}

  async canActivate(context: ExecutionContext): Promise&lt;boolean&gt; {
    const request = context.switchToHttp().getRequest()
    const apiKey = request.headers[&#39;x-api-key&#39;]
    
    if (!apiKey) {
      throw new UnauthorizedException(&#39;API key required&#39;)
    }

    // Validate API key format
    if (!this.isValidApiKeyFormat(apiKey)) {
      throw new UnauthorizedException(&#39;Invalid API key format&#39;)
    }

    // Check against hashed keys in database
    const hashedKey = await this.cryptoService.hash(apiKey)
    const validKey = await this.prisma.apiKey.findFirst({
      where: { 
        keyHash: hashedKey,
        active: true,
        expiresAt: { gt: new Date() }
      }
    })

    if (!validKey) {
      throw new UnauthorizedException(&#39;Invalid API key&#39;)
    }

    // Log API key usage
    await this.logApiKeyUsage(validKey.id)
    
    return true
  }

  private isValidApiKeyFormat(key: string): boolean {
    // Example: sk_live_xxxxxxxxxxxxxxxx
    return /^sk_(test|live)_[a-zA-Z0-9]{32}$/.test(key)
  }
}
</code></pre>
<h2 id="infrastructure-security">Infrastructure Security</h2>
<h3 id="environment-variables">Environment Variables</h3>
<pre><code class="language-typescript">// libs/config/src/lib/config.validation.ts
import * as Joi from &#39;joi&#39;

export const configValidationSchema = Joi.object({
  NODE_ENV: Joi.string()
    .valid(&#39;development&#39;, &#39;production&#39;, &#39;test&#39;)
    .required(),
  
  DATABASE_URL: Joi.string()
    .pattern(/^postgresql:\/\//)
    .required(),
  
  JWT_SECRET: Joi.string()
    .min(32)
    .required(),
  
  ENCRYPTION_KEY: Joi.string()
    .hex()
    .length(64) // 32 bytes in hex
    .required(),
  
  ALLOWED_ORIGINS: Joi.string()
    .pattern(/^https:\/\//)
    .required(),
})

// Validate on startup
ConfigModule.forRoot({
  validationSchema: configValidationSchema,
  validationOptions: {
    abortEarly: false,
  }
})
</code></pre>
<h3 id="secrets-management">Secrets Management</h3>
<pre><code class="language-typescript">// Use AWS Secrets Manager in production
@Injectable()
export class SecretsService {
  private client = new SecretsManagerClient({ region: &#39;us-east-1&#39; })

  async getSecret(secretName: string): Promise&lt;string&gt; {
    try {
      const response = await this.client.send(
        new GetSecretValueCommand({ SecretId: secretName })
      )
      
      return response.SecretString || &#39;&#39;
    } catch (error) {
      console.error(&#39;Failed to retrieve secret:&#39;, error)
      throw new Error(&#39;Secret retrieval failed&#39;)
    }
  }

  // Cache secrets to reduce API calls
  @Memoize({ ttl: 300000 }) // 5 minutes
  async getCachedSecret(secretName: string): Promise&lt;string&gt; {
    return this.getSecret(secretName)
  }
}
</code></pre>
<h2 id="dependency-security">Dependency Security</h2>
<h3 id="automated-scanning">Automated Scanning</h3>
<pre><code class="language-json">// package.json
{
  &quot;scripts&quot;: {
    &quot;security:check&quot;: &quot;npm audit --audit-level=moderate&quot;,
    &quot;security:fix&quot;: &quot;npm audit fix&quot;,
    &quot;security:snyk&quot;: &quot;snyk test&quot;,
    &quot;security:owasp&quot;: &quot;dependency-check --scan . --format JSON --out dependency-check-report.json&quot;
  }
}
</code></pre>
<h3 id="github-actions-security-workflow">GitHub Actions Security Workflow</h3>
<pre><code class="language-yaml"># .github/workflows/security.yml
name: Security Scan

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  schedule:
    - cron: &#39;0 0 * * *&#39; # Daily

jobs:
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Run Snyk
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high
      
      - name: Run npm audit
        run: npm audit --audit-level=moderate
      
      - name: Run CodeQL
        uses: github/codeql-action/analyze@v2
      
      - name: Run Trivy
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: &#39;fs&#39;
          scan-ref: &#39;.&#39;
          format: &#39;sarif&#39;
          output: &#39;trivy-results.sarif&#39;
</code></pre>
<h2 id="monitoring-auditing">Monitoring &amp; Auditing</h2>
<h3 id="security-event-monitoring">Security Event Monitoring</h3>
<pre><code class="language-typescript">@Injectable()
export class SecurityMonitoringService {
  private readonly events = new EventEmitter()

  async logSecurityEvent(event: SecurityEvent) {
    // Log to persistent storage
    await this.prisma.securityEvent.create({
      data: {
        type: event.type,
        severity: event.severity,
        userId: event.userId,
        ipAddress: event.ipAddress,
        userAgent: event.userAgent,
        details: event.details,
        timestamp: new Date()
      }
    })

    // Alert on critical events
    if (event.severity === &#39;CRITICAL&#39;) {
      this.events.emit(&#39;critical-security-event&#39;, event)
    }

    // Send to SIEM
    await this.sendToSiem(event)
  }

  // Monitor suspicious activities
  async checkSuspiciousActivity(userId: string) {
    const recentEvents = await this.prisma.securityEvent.count({
      where: {
        userId,
        type: &#39;FAILED_LOGIN&#39;,
        timestamp: { gte: new Date(Date.now() - 3600000) } // Last hour
      }
    })

    if (recentEvents &gt; 5) {
      await this.logSecurityEvent({
        type: &#39;ACCOUNT_LOCKOUT&#39;,
        severity: &#39;HIGH&#39;,
        userId,
        details: &#39;Too many failed login attempts&#39;
      })
    }
  }
}
</code></pre>
<h3 id="compliance-logging">Compliance Logging</h3>
<pre><code class="language-typescript">@Injectable()
export class ComplianceLogger {
  async logDataProcessing(operation: DataOperation) {
    await this.prisma.dataProcessingLog.create({
      data: {
        userId: operation.userId,
        dataType: operation.dataType,
        purpose: operation.purpose,
        legalBasis: operation.legalBasis,
        timestamp: new Date(),
        // For GDPR compliance
        retention: operation.retentionPeriod,
        dataSubjects: operation.affectedUsers
      }
    })
  }

  async logDataExport(userId: string, exportedData: string[]) {
    await this.prisma.dataExportLog.create({
      data: {
        userId,
        exportedData,
        timestamp: new Date(),
        // Hash for integrity verification
        checksum: this.calculateChecksum(exportedData)
      }
    })
  }
}
</code></pre>
<h2 id="security-checklist">Security Checklist</h2>
<h3 id="development-phase">Development Phase</h3>
<ul>
<li><input disabled="" type="checkbox"> Input validation on all endpoints</li>
<li><input disabled="" type="checkbox"> Output encoding for all responses</li>
<li><input disabled="" type="checkbox"> Authentication required for sensitive operations</li>
<li><input disabled="" type="checkbox"> Authorization checks for all resources</li>
<li><input disabled="" type="checkbox"> Rate limiting configured</li>
<li><input disabled="" type="checkbox"> SQL injection prevention verified</li>
<li><input disabled="" type="checkbox"> XSS protection implemented</li>
<li><input disabled="" type="checkbox"> CSRF protection enabled</li>
<li><input disabled="" type="checkbox"> Security headers configured</li>
<li><input disabled="" type="checkbox"> Dependency vulnerabilities scanned</li>
</ul>
<h3 id="pre-production">Pre-Production</h3>
<ul>
<li><input disabled="" type="checkbox"> Security testing completed</li>
<li><input disabled="" type="checkbox"> Penetration testing performed</li>
<li><input disabled="" type="checkbox"> Code security review done</li>
<li><input disabled="" type="checkbox"> Secrets removed from code</li>
<li><input disabled="" type="checkbox"> Environment variables validated</li>
<li><input disabled="" type="checkbox"> SSL/TLS certificates ready</li>
<li><input disabled="" type="checkbox"> Backup encryption tested</li>
<li><input disabled="" type="checkbox"> Audit logging functional</li>
<li><input disabled="" type="checkbox"> Monitoring alerts configured</li>
<li><input disabled="" type="checkbox"> Incident response plan ready</li>
</ul>
<h3 id="production">Production</h3>
<ul>
<li><input disabled="" type="checkbox"> HTTPS enforced everywhere</li>
<li><input disabled="" type="checkbox"> Security headers active</li>
<li><input disabled="" type="checkbox"> Rate limiting operational</li>
<li><input disabled="" type="checkbox"> Monitoring active</li>
<li><input disabled="" type="checkbox"> Alerts configured</li>
<li><input disabled="" type="checkbox"> Backups encrypted</li>
<li><input disabled="" type="checkbox"> Access logs enabled</li>
<li><input disabled="" type="checkbox"> Security patches automated</li>
<li><input disabled="" type="checkbox"> Compliance requirements met</li>
<li><input disabled="" type="checkbox"> Regular security audits scheduled</li>
</ul>
<h2 id="security-resources">Security Resources</h2>
<ul>
<li><a href="https://owasp.org/www-project-top-ten/">OWASP Top 10</a></li>
<li><a href="https://blog.risingstack.com/node-js-security-checklist/">Node.js Security Checklist</a></li>
<li><a href="https://www.apollographql.com/docs/apollo-server/security/authentication/">GraphQL Security</a></li>
<li><a href="https://docs.nestjs.com/security/helmet">NestJS Security</a></li>
</ul>
<p>Remember: Security is not a one-time task but an ongoing process. Regular reviews and updates are essential.</p>
</div><div id="05-operations-01-deployment" class="doc-section"><h1 id="deployment-guide">Deployment Guide</h1>
<p>This guide covers various deployment strategies for the NestJS GraphQL Microservices architecture.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#environment-configuration">Environment Configuration</a></li>
<li><a href="#containerization">Containerization</a></li>
<li><a href="#deployment-strategies">Deployment Strategies</a><ul>
<li><a href="#docker-compose-production">Docker Compose</a></li>
<li><a href="#kubernetes-deployment">Kubernetes</a></li>
<li><a href="#aws-ecs">AWS ECS</a></li>
<li><a href="#google-cloud-run">Google Cloud Run</a></li>
<li><a href="#heroku-deployment">Heroku</a></li>
</ul>
</li>
<li><a href="#database-deployment">Database Deployment</a></li>
<li><a href="#cicd-pipeline">CI/CD Pipeline</a></li>
<li><a href="#monitoring-logging">Monitoring &amp; Logging</a></li>
<li><a href="#scaling-strategies">Scaling Strategies</a></li>
<li><a href="#security-checklist">Security Checklist</a></li>
</ul>
<h2 id="prerequisites">Prerequisites</h2>
<p>Before deploying, ensure you have:</p>
<ul>
<li><input disabled="" type="checkbox"> All environment variables configured</li>
<li><input disabled="" type="checkbox"> Database migrations tested</li>
<li><input disabled="" type="checkbox"> Docker images built and tested</li>
<li><input disabled="" type="checkbox"> SSL certificates ready</li>
<li><input disabled="" type="checkbox"> Domain names configured</li>
<li><input disabled="" type="checkbox"> Monitoring solutions chosen</li>
</ul>
<h2 id="environment-configuration">Environment Configuration</h2>
<h3 id="production-environment-variables">Production Environment Variables</h3>
<p>Create production <code>.env</code> files:</p>
<pre><code class="language-env"># .env.production
NODE_ENV=production

# API Gateway
GATEWAY_PORT=3000
APOLLO_KEY=your-apollo-studio-key
APOLLO_GRAPH_REF=your-graph@production

# Users Service
USERS_SERVICE_PORT=3001
USERS_DATABASE_URL=postgresql://user:pass@prod-db:5432/users?schema=public
JWT_SECRET=your-production-jwt-secret
BCRYPT_ROUNDS=12

# Products Service
PRODUCTS_SERVICE_PORT=3002
PRODUCTS_DATABASE_URL=postgresql://user:pass@prod-db:5433/products?schema=public

# Security
CORS_ORIGIN=https://your-domain.com
RATE_LIMIT_MAX=100
RATE_LIMIT_WINDOW=15m
</code></pre>
<h3 id="configuration-management">Configuration Management</h3>
<p>Use a configuration service or secrets manager:</p>
<pre><code class="language-typescript">// libs/config/src/lib/config.service.ts
@Injectable()
export class ConfigService {
  get(key: string): string {
    // In production, fetch from AWS Secrets Manager, Vault, etc.
    if (process.env.NODE_ENV === &#39;production&#39;) {
      return this.getFromSecretsManager(key)
    }
    return process.env[key]
  }
}
</code></pre>
<h2 id="containerization">Containerization</h2>
<h3 id="multi-stage-docker-build">Multi-Stage Docker Build</h3>
<p>Create optimized Docker images:</p>
<pre><code class="language-dockerfile"># apps/users-service/Dockerfile
FROM node:18-alpine AS dependencies
WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN npm install -g pnpm &amp;&amp; pnpm install --frozen-lockfile

FROM node:18-alpine AS builder
WORKDIR /app
COPY . .
COPY --from=dependencies /app/node_modules ./node_modules
RUN npm install -g pnpm @nx/cli
RUN pnpm nx build users-service --configuration=production

FROM node:18-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production
RUN addgroup -g 1001 -S nodejs &amp;&amp; adduser -S nestjs -u 1001

COPY --from=builder /app/dist/apps/users-service ./
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/apps/users-service/prisma ./prisma

USER nestjs
EXPOSE 3001
CMD [&quot;node&quot;, &quot;main.js&quot;]
</code></pre>
<h3 id="build-all-services">Build All Services</h3>
<pre><code class="language-bash"># Build script (scripts/build-docker.sh)
#!/bin/bash
docker build -f apps/api-gateway/Dockerfile -t myapp/gateway:latest .
docker build -f apps/users-service/Dockerfile -t myapp/users:latest .
docker build -f apps/products-service/Dockerfile -t myapp/products:latest .
</code></pre>
<h2 id="deployment-strategies">Deployment Strategies</h2>
<h3 id="docker-compose-production">Docker Compose Production</h3>
<pre><code class="language-yaml"># docker-compose.prod.yml
version: &#39;3.8&#39;

services:
  gateway:
    image: myapp/gateway:latest
    ports:
      - &quot;80:3000&quot;
    environment:
      - NODE_ENV=production
    depends_on:
      - users-service
      - products-service
    restart: always
    healthcheck:
      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:3000/health&quot;]
      interval: 30s
      timeout: 10s
      retries: 3

  users-service:
    image: myapp/users:latest
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${USERS_DATABASE_URL}
    depends_on:
      - postgres-users
    restart: always
    healthcheck:
      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:3001/health&quot;]

  products-service:
    image: myapp/products:latest
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${PRODUCTS_DATABASE_URL}
    depends_on:
      - postgres-products
    restart: always

  postgres-users:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: users_prod
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - users-data:/var/lib/postgresql/data
    restart: always

  postgres-products:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: products_prod
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - products-data:/var/lib/postgresql/data
    restart: always

  nginx:
    image: nginx:alpine
    ports:
      - &quot;443:443&quot;
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - gateway
    restart: always

volumes:
  users-data:
  products-data:
</code></pre>
<h3 id="kubernetes-deployment">Kubernetes Deployment</h3>
<h4 id="service-deployment">Service Deployment</h4>
<pre><code class="language-yaml"># k8s/users-service.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: users-service
  labels:
    app: users-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: users-service
  template:
    metadata:
      labels:
        app: users-service
    spec:
      containers:
      - name: users-service
        image: myapp/users:latest
        ports:
        - containerPort: 3001
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: users-secrets
              key: database-url
        - name: NODE_ENV
          value: &quot;production&quot;
        resources:
          requests:
            memory: &quot;256Mi&quot;
            cpu: &quot;250m&quot;
          limits:
            memory: &quot;512Mi&quot;
            cpu: &quot;500m&quot;
        livenessProbe:
          httpGet:
            path: /health
            port: 3001
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3001
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: users-service
spec:
  selector:
    app: users-service
  ports:
    - port: 3001
      targetPort: 3001
  type: ClusterIP
</code></pre>
<h4 id="ingress-configuration">Ingress Configuration</h4>
<pre><code class="language-yaml"># k8s/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: api-gateway-ingress
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
spec:
  tls:
  - hosts:
    - api.yourdomain.com
    secretName: api-tls
  rules:
  - host: api.yourdomain.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: api-gateway
            port:
              number: 3000
</code></pre>
<h3 id="aws-ecs">AWS ECS</h3>
<h4 id="task-definition">Task Definition</h4>
<pre><code class="language-json">{
  &quot;family&quot;: &quot;users-service&quot;,
  &quot;networkMode&quot;: &quot;awsvpc&quot;,
  &quot;requiresCompatibilities&quot;: [&quot;FARGATE&quot;],
  &quot;cpu&quot;: &quot;512&quot;,
  &quot;memory&quot;: &quot;1024&quot;,
  &quot;containerDefinitions&quot;: [
    {
      &quot;name&quot;: &quot;users-service&quot;,
      &quot;image&quot;: &quot;123456789.dkr.ecr.us-east-1.amazonaws.com/users-service:latest&quot;,
      &quot;portMappings&quot;: [
        {
          &quot;containerPort&quot;: 3001,
          &quot;protocol&quot;: &quot;tcp&quot;
        }
      ],
      &quot;environment&quot;: [
        {
          &quot;name&quot;: &quot;NODE_ENV&quot;,
          &quot;value&quot;: &quot;production&quot;
        }
      ],
      &quot;secrets&quot;: [
        {
          &quot;name&quot;: &quot;DATABASE_URL&quot;,
          &quot;valueFrom&quot;: &quot;arn:aws:secretsmanager:region:account:secret:db-url&quot;
        }
      ],
      &quot;healthCheck&quot;: {
        &quot;command&quot;: [&quot;CMD-SHELL&quot;, &quot;curl -f http://localhost:3001/health || exit 1&quot;],
        &quot;interval&quot;: 30,
        &quot;timeout&quot;: 5,
        &quot;retries&quot;: 3
      },
      &quot;logConfiguration&quot;: {
        &quot;logDriver&quot;: &quot;awslogs&quot;,
        &quot;options&quot;: {
          &quot;awslogs-group&quot;: &quot;/ecs/users-service&quot;,
          &quot;awslogs-region&quot;: &quot;us-east-1&quot;,
          &quot;awslogs-stream-prefix&quot;: &quot;ecs&quot;
        }
      }
    }
  ]
}
</code></pre>
<h3 id="google-cloud-run">Google Cloud Run</h3>
<pre><code class="language-yaml"># cloudbuild.yaml
steps:
  # Build images
  - name: &#39;gcr.io/cloud-builders/docker&#39;
    args: [&#39;build&#39;, &#39;-t&#39;, &#39;gcr.io/$PROJECT_ID/users-service&#39;, &#39;-f&#39;, &#39;apps/users-service/Dockerfile&#39;, &#39;.&#39;]
  
  # Push to registry
  - name: &#39;gcr.io/cloud-builders/docker&#39;
    args: [&#39;push&#39;, &#39;gcr.io/$PROJECT_ID/users-service&#39;]
  
  # Deploy to Cloud Run
  - name: &#39;gcr.io/cloud-builders/gcloud&#39;
    args:
      - &#39;run&#39;
      - &#39;deploy&#39;
      - &#39;users-service&#39;
      - &#39;--image=gcr.io/$PROJECT_ID/users-service&#39;
      - &#39;--region=us-central1&#39;
      - &#39;--platform=managed&#39;
      - &#39;--allow-unauthenticated&#39;
      - &#39;--set-env-vars=NODE_ENV=production&#39;
      - &#39;--set-secrets=DATABASE_URL=users-db-url:latest&#39;
</code></pre>
<h3 id="heroku-deployment">Heroku Deployment</h3>
<pre><code class="language-json">// package.json additions
{
  &quot;scripts&quot;: {
    &quot;heroku-postbuild&quot;: &quot;pnpm nx build api-gateway --configuration=production&quot;,
    &quot;start:prod&quot;: &quot;node dist/apps/api-gateway/main.js&quot;
  }
}
</code></pre>
<pre><code class="language-yaml"># heroku.yml
build:
  docker:
    web: apps/api-gateway/Dockerfile
run:
  web: node main.js
</code></pre>
<h2 id="database-deployment">Database Deployment</h2>
<h3 id="managed-database-services">Managed Database Services</h3>
<h4 id="aws-rds">AWS RDS</h4>
<pre><code class="language-typescript">// terraform/rds.tf
resource &quot;aws_db_instance&quot; &quot;users&quot; {
  identifier = &quot;users-prod&quot;
  engine     = &quot;postgres&quot;
  engine_version = &quot;16&quot;
  instance_class = &quot;db.t3.micro&quot;
  allocated_storage = 20
  storage_encrypted = true
  
  db_name  = &quot;users_prod&quot;
  username = var.db_username
  password = var.db_password
  
  vpc_security_group_ids = [aws_security_group.rds.id]
  db_subnet_group_name   = aws_db_subnet_group.main.name
  
  backup_retention_period = 7
  backup_window = &quot;03:00-04:00&quot;
  maintenance_window = &quot;sun:04:00-sun:05:00&quot;
  
  skip_final_snapshot = false
  deletion_protection = true
}
</code></pre>
<h3 id="database-migrations">Database Migrations</h3>
<pre><code class="language-bash"># Run migrations during deployment
#!/bin/bash
echo &quot;Running database migrations...&quot;
pnpm prisma migrate deploy --schema=apps/users-service/prisma/schema.prisma
pnpm prisma migrate deploy --schema=apps/products-service/prisma/schema.prisma
</code></pre>
<h2 id="cicd-pipeline">CI/CD Pipeline</h2>
<h3 id="github-actions">GitHub Actions</h3>
<pre><code class="language-yaml"># .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: pnpm/action-setup@v2
      - uses: actions/setup-node@v3
        with:
          node-version: 18
          cache: &#39;pnpm&#39;
      
      - run: pnpm install --frozen-lockfile
      - run: pnpm nx affected:test --base=origin/main~1
      - run: pnpm nx affected:lint --base=origin/main~1

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
      
      - name: Build and push images
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          docker build -f apps/api-gateway/Dockerfile -t $ECR_REGISTRY/api-gateway:$GITHUB_SHA .
          docker build -f apps/users-service/Dockerfile -t $ECR_REGISTRY/users-service:$GITHUB_SHA .
          docker build -f apps/products-service/Dockerfile -t $ECR_REGISTRY/products-service:$GITHUB_SHA .
          
          docker push $ECR_REGISTRY/api-gateway:$GITHUB_SHA
          docker push $ECR_REGISTRY/users-service:$GITHUB_SHA
          docker push $ECR_REGISTRY/products-service:$GITHUB_SHA

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to ECS
        run: |
          aws ecs update-service --cluster production --service api-gateway --force-new-deployment
          aws ecs update-service --cluster production --service users-service --force-new-deployment
          aws ecs update-service --cluster production --service products-service --force-new-deployment
</code></pre>
<h2 id="monitoring-logging">Monitoring &amp; Logging</h2>
<h3 id="application-monitoring">Application Monitoring</h3>
<pre><code class="language-typescript">// libs/monitoring/src/lib/monitoring.module.ts
import { PrometheusModule } from &#39;@willsoto/nestjs-prometheus&#39;
import { LoggerModule } from &#39;nestjs-pino&#39;

@Module({
  imports: [
    PrometheusModule.register({
      defaultMetrics: {
        enabled: true,
      },
      path: &#39;/metrics&#39;,
    }),
    LoggerModule.forRoot({
      pinoHttp: {
        level: process.env.LOG_LEVEL || &#39;info&#39;,
        transport: process.env.NODE_ENV !== &#39;production&#39; 
          ? { target: &#39;pino-pretty&#39; }
          : undefined,
      },
    }),
  ],
})
export class MonitoringModule {}
</code></pre>
<h3 id="health-checks">Health Checks</h3>
<pre><code class="language-typescript">// apps/users-service/src/health/health.controller.ts
@Controller(&#39;health&#39;)
export class HealthController {
  constructor(
    private health: HealthCheckService,
    private db: PrismaHealthIndicator,
  ) {}

  @Get()
  @HealthCheck()
  check() {
    return this.health.check([
      () =&gt; this.db.pingCheck(&#39;database&#39;),
    ])
  }

  @Get(&#39;ready&#39;)
  ready() {
    return { status: &#39;ready&#39; }
  }
}
</code></pre>
<h2 id="scaling-strategies">Scaling Strategies</h2>
<h3 id="horizontal-pod-autoscaling">Horizontal Pod Autoscaling</h3>
<pre><code class="language-yaml"># k8s/hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: users-service-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: users-service
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
</code></pre>
<h3 id="database-connection-pooling">Database Connection Pooling</h3>
<pre><code class="language-typescript">// Configure Prisma connection pool
datasource db {
  provider = &quot;postgresql&quot;
  url      = env(&quot;DATABASE_URL&quot;)
  connectionLimit = 10
}
</code></pre>
<h2 id="security-checklist">Security Checklist</h2>
<h3 id="pre-deployment">Pre-Deployment</h3>
<ul>
<li><input disabled="" type="checkbox"> Environment variables secured</li>
<li><input disabled="" type="checkbox"> Secrets in secret manager</li>
<li><input disabled="" type="checkbox"> SSL/TLS configured</li>
<li><input disabled="" type="checkbox"> Rate limiting enabled</li>
<li><input disabled="" type="checkbox"> CORS properly configured</li>
<li><input disabled="" type="checkbox"> Authentication/Authorization tested</li>
<li><input disabled="" type="checkbox"> Input validation active</li>
<li><input disabled="" type="checkbox"> SQL injection prevention verified</li>
<li><input disabled="" type="checkbox"> XSS protection enabled</li>
<li><input disabled="" type="checkbox"> Dependency vulnerabilities scanned</li>
</ul>
<h3 id="post-deployment">Post-Deployment</h3>
<ul>
<li><input disabled="" type="checkbox"> Security headers configured</li>
<li><input disabled="" type="checkbox"> Monitoring alerts set up</li>
<li><input disabled="" type="checkbox"> Backup strategy implemented</li>
<li><input disabled="" type="checkbox"> Disaster recovery tested</li>
<li><input disabled="" type="checkbox"> Access logs enabled</li>
<li><input disabled="" type="checkbox"> Intrusion detection active</li>
</ul>
<h2 id="rollback-strategy">Rollback Strategy</h2>
<h3 id="blue-green-deployment">Blue-Green Deployment</h3>
<pre><code class="language-bash">#!/bin/bash
# Deploy to green environment
kubectl set image deployment/users-service users-service=myapp/users:$NEW_VERSION -n green

# Test green environment
./scripts/smoke-tests.sh https://green.api.domain.com

# Switch traffic
kubectl patch service users-service -p &#39;{&quot;spec&quot;:{&quot;selector&quot;:{&quot;version&quot;:&quot;green&quot;}}}&#39;

# Keep blue as backup
echo &quot;Blue environment kept as rollback option&quot;
</code></pre>
<h3 id="database-rollback">Database Rollback</h3>
<pre><code class="language-bash"># Always backup before migration
pg_dump $DATABASE_URL &gt; backup-$(date +%Y%m%d-%H%M%S).sql

# Rollback if needed
psql $DATABASE_URL &lt; backup-20240101-120000.sql
</code></pre>
<h2 id="performance-optimization">Performance Optimization</h2>
<h3 id="cdn-configuration">CDN Configuration</h3>
<pre><code class="language-nginx"># nginx.conf
location /graphql {
    proxy_pass http://gateway:3000;
    proxy_cache_bypass $http_upgrade;
    
    # Don&#39;t cache mutations
    proxy_cache_methods GET HEAD;
    proxy_cache_valid 200 1m;
    
    add_header X-Cache-Status $upstream_cache_status;
}
</code></pre>
<h3 id="query-complexity-limits">Query Complexity Limits</h3>
<pre><code class="language-typescript">GraphQLModule.forRoot({
  validationRules: [
    depthLimit(7),
    costAnalysis({
      maximumCost: 1000,
      defaultCost: 1,
    }),
  ],
})
</code></pre>
<h2 id="next-steps">Next Steps</h2>
<ul>
<li>Set up monitoring dashboards</li>
<li>Configure alerting rules</li>
<li>Implement automated backups</li>
<li>Plan disaster recovery drills</li>
<li>Schedule security audits</li>
<li>Document runbooks</li>
</ul>
</div>
            </div>
            <a href="#top" class="back-to-top" id="back-to-top">‚Üë Back to Top</a>
        </main>
    </div>
    <script>
        // Smooth scrolling for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const target = document.getElementById(targetId);
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    // Update active link
                    document.querySelectorAll('.sidebar a').forEach(link => {
                        link.classList.remove('active');
                    });
                    this.classList.add('active');
                }
            });
        });

        // Show/hide back to top button
        const backToTop = document.getElementById('back-to-top');
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                backToTop.style.display = 'block';
            } else {
                backToTop.style.display = 'none';
            }
        });

        // Back to top functionality
        backToTop.addEventListener('click', function(e) {
            e.preventDefault();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Search functionality
        const searchInput = document.getElementById('search-input');
        const docSections = document.querySelectorAll('.doc-section');
        const sidebarLinks = document.querySelectorAll('.sidebar a');

        searchInput.addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            
            if (searchTerm.length < 2) {
                // Show all sections and links if search is too short
                docSections.forEach(section => section.classList.remove('hidden'));
                sidebarLinks.forEach(link => link.parentElement.classList.remove('hidden'));
                return;
            }

            // Search in content
            docSections.forEach(section => {
                const content = section.textContent.toLowerCase();
                if (content.includes(searchTerm)) {
                    section.classList.remove('hidden');
                    // Highlight search term (basic implementation)
                    // Note: This is a simple approach, for production use a proper highlighting library
                } else {
                    section.classList.add('hidden');
                }
            });

            // Filter sidebar links
            sidebarLinks.forEach(link => {
                const linkText = link.textContent.toLowerCase();
                const targetId = link.getAttribute('href').substring(1);
                const targetSection = document.getElementById(targetId);
                
                if (linkText.includes(searchTerm) || (targetSection && !targetSection.classList.contains('hidden'))) {
                    link.parentElement.classList.remove('hidden');
                } else {
                    link.parentElement.classList.add('hidden');
                }
            });
        });

        // Highlight active section on scroll
        const observerOptions = {
            root: null,
            rootMargin: '0px',
            threshold: 0.1
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.id;
                    document.querySelectorAll('.sidebar a').forEach(link => {
                        link.classList.remove('active');
                        if (link.getAttribute('href') === '#' + id) {
                            link.classList.add('active');
                        }
                    });
                }
            });
        }, observerOptions);

        // Observe all sections
        docSections.forEach(section => {
            observer.observe(section);
        });
    </script>
</body>
</html>